(()=>{"use strict";var e=1e-6,t="undefined"!=typeof Float32Array?Float32Array:Array;function n(){var e=new t(3);return t!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function r(e,n,r){var i=new t(3);return i[0]=e,i[1]=n,i[2]=r,i}function i(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e}function s(e,t){var n=t[0],r=t[1],i=t[2],s=n*n+r*r+i*i;return s>0&&(s=1/Math.sqrt(s)),e[0]=t[0]*s,e[1]=t[1]*s,e[2]=t[2]*s,e}Math.random,Math.PI,Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});var o=function(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e};function a(){var e=new t(2);return t!=Float32Array&&(e[0]=0,e[1]=0),e}n();var l=function(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e};function c(e,t,n){return Math.min(Math.max(e,t),n)}function u(e,t=1){const n=void 0!==e?e:t;return Number.isInteger(n)?`${n}.0`:n}function h(e,t,n){const r=n.createBuffer({size:e.byteLength+3&-4,usage:t,mappedAtCreation:!0});let i;return i=e instanceof Int8Array?new Int8Array(r.getMappedRange()):e instanceof Uint8Array?new Uint8Array(r.getMappedRange()):e instanceof Int16Array?new Int16Array(r.getMappedRange()):e instanceof Uint16Array?new Uint16Array(r.getMappedRange()):e instanceof Uint32Array?new Uint32Array(r.getMappedRange()):new Float32Array(r.getMappedRange()),i.set(e),r.unmap(),r}a();const d={9728:"nearest",9729:"linear",9984:"linear",9985:"linear",9986:"linear",9987:"linear",33071:"clamp-to-edge",33648:"mirror-repeat",10497:"repeat"};class f{constructor(e,c,u){function h(t,n){const r=e.accessors[t],i=e.bufferViews[r.bufferView],s=(i.byteOffset||0)+(r.byteOffset||0);let o=i.byteStride/4;o=o>n?o:n;const a=function(e,t,n,r){switch(e){case 5120:return new Int8Array(t,n,r);case 5121:return new Uint8Array(t,n,r);case 5122:return new Int16Array(t,n,r);case 5123:return new Uint16Array(t,n,r);case 5125:return new Uint32Array(t,n,r);case 5126:return new Float32Array(t,n,r);default:throw new Error("invalid component type")}}(r.componentType,u[i.buffer],s,r.count*o);if(o>n){const e=new(0,a.constructor)(r.count*n);for(let t=0,r=0;t<e.length;t+=n,r+=o)for(let i=0;i<n;i+=1)e[t+i]=a[r+i];return e}return a}e.materials&&void 0!==c.material?this.material=e.materials[c.material]:this.material={},this.material.pbrMetallicRoughness||(this.material.pbrMetallicRoughness={}),void 0!==c.indices?(this.indices=function(e){if(e instanceof Uint16Array||e instanceof Uint32Array)return e;let t;return t=e instanceof Float32Array?new Uint32Array(e.length):new Uint16Array(e.length),e.forEach(((e,n)=>{t[n]=e})),t}(h(c.indices,1)),this.vertexCount=e.accessors[c.indices].count):this.vertexCount=e.accessors[c.attributes.POSITION].count,this.positions=h(c.attributes.POSITION,3),void 0!==c.attributes.NORMAL?this.normals=h(c.attributes.NORMAL,3):this.normals=function(e,t){const i=new Float32Array(t.length),a=e?e.length:t.length;for(let g=0;g<a;g+=3){const a=[];for(let t=0;t<3;t+=1)e?a.push(e[g+t]):a.push(g+t);const x=a.map((e=>{const n=3*e;return r(t[n],t[n+1],t[n+2])})),y=n();o(y,x[1],x[0]);const w=n();o(w,x[2],x[0]);const b=n();l=b,c=s(y,y),u=s(y,w),void 0,void 0,void 0,void 0,void 0,void 0,h=c[0],d=c[1],f=c[2],m=u[0],v=u[1],p=u[2],l[0]=d*p-f*v,l[1]=f*m-h*p,l[2]=h*v-d*m;for(let e=0;e<3;e+=1){const t=3*(g+e);for(let e=0;e<3;e+=1)i[t+e]+=b[e]}}var l,c,u,h,d,f,m,v,p;return i}(this.indices,this.positions),void 0!==c.attributes.TEXCOORD_0&&(this.uvs=h(c.attributes.TEXCOORD_0,2)),void 0!==c.attributes.TEXCOORD_1&&(this.uv1s=h(c.attributes.TEXCOORD_1,2)),void 0!==c.attributes.TANGENT&&void 0!==c.attributes.NORMAL?this.tangents=h(c.attributes.TANGENT,4):this.material.normalTexture&&(this.tangents=function(e,c,u,h){const d=new Float32Array(u.length/3*4),f=e?e.length:c.length;for(let u=0;u<f;u+=3){const f=[];for(let t=0;t<3;t+=1)e?f.push(e[u+t]):f.push(u+t);const m=f.map((e=>{const t=3*e;return r(c[t],c[t+1],c[t+2])})),v=f.map((e=>{const n=2*e;return r=h[n],i=h[n+1],(s=new t(2))[0]=r,s[1]=i,s;var r,i,s})),p=n();o(p,m[1],m[0]);const g=n();o(g,m[2],m[0]);const x=a();l(x,v[1],v[0]);const y=a();l(y,v[2],v[0]);const w=y[1]*x[0]-x[1]*y[0]>=0?1:-1,b=n();o(b,i(p,p,y[1]),i(g,g,x[1])),s(b,b);for(let e=0;e<3;e+=1){const t=4*(u+e);for(let e=0;e<3;e+=1)d[t+e]+=b[e];d[t+3]=w}}return d}(this.indices,this.positions,this.normals,this.uvs)),void 0!==c.attributes.COLOR_0&&(this.colors=h(c.attributes.COLOR_0,4))}}var m=function(e,t,n,r){return new(n||(n=Promise))((function(i,s){function o(e){try{l(r.next(e))}catch(e){s(e)}}function a(e){try{l(r.throw(e))}catch(e){s(e)}}function l(e){var t;e.done?i(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(o,a)}l((r=r.apply(e,t||[])).next())}))};class v{constructor(e,t,n){this.scenes=e.scenes,this.scene=e.scene,this.nodes=e.nodes,this.cameras=e.cameras,this.meshes=t,this.textures=e.textures?e.textures.map((t=>{let r;return r=void 0!==t.sampler?e.samplers[t.sampler]:{},{source:n[t.source],sampler:{magFilter:d[r.magFilter||9729],minFilter:d[r.minFilter||9729],addressModeU:d[r.wrapS||10497],addressModeV:d[r.wrapT||10497]}}})):[]}}function p(){var e=new t(16);return t!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function g(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=t[4],a=t[5],l=t[6],c=t[7],u=t[8],h=t[9],d=t[10],f=t[11],m=t[12],v=t[13],p=t[14],g=t[15],x=n*a-r*o,y=n*l-i*o,w=n*c-s*o,b=r*l-i*a,T=r*c-s*a,M=i*c-s*l,E=u*v-h*m,P=u*p-d*m,$=u*g-f*m,U=h*p-d*v,R=h*g-f*v,A=d*g-f*p,C=x*A-y*R+w*U+b*$-T*P+M*E;return C?(C=1/C,e[0]=(a*A-l*R+c*U)*C,e[1]=(i*R-r*A-s*U)*C,e[2]=(v*M-p*T+g*b)*C,e[3]=(d*T-h*M-f*b)*C,e[4]=(l*$-o*A-c*P)*C,e[5]=(n*A-i*$+s*P)*C,e[6]=(p*w-m*M-g*y)*C,e[7]=(u*M-d*w+f*y)*C,e[8]=(o*R-a*$+c*E)*C,e[9]=(r*$-n*R-s*E)*C,e[10]=(m*T-v*w+g*x)*C,e[11]=(h*w-u*T-f*x)*C,e[12]=(a*P-o*U-l*E)*C,e[13]=(n*U-r*P+i*E)*C,e[14]=(v*y-m*b-p*x)*C,e[15]=(u*b-h*y+d*x)*C,e):null}function x(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],a=t[4],l=t[5],c=t[6],u=t[7],h=t[8],d=t[9],f=t[10],m=t[11],v=t[12],p=t[13],g=t[14],x=t[15],y=n[0],w=n[1],b=n[2],T=n[3];return e[0]=y*r+w*a+b*h+T*v,e[1]=y*i+w*l+b*d+T*p,e[2]=y*s+w*c+b*f+T*g,e[3]=y*o+w*u+b*m+T*x,y=n[4],w=n[5],b=n[6],T=n[7],e[4]=y*r+w*a+b*h+T*v,e[5]=y*i+w*l+b*d+T*p,e[6]=y*s+w*c+b*f+T*g,e[7]=y*o+w*u+b*m+T*x,y=n[8],w=n[9],b=n[10],T=n[11],e[8]=y*r+w*a+b*h+T*v,e[9]=y*i+w*l+b*d+T*p,e[10]=y*s+w*c+b*f+T*g,e[11]=y*o+w*u+b*m+T*x,y=n[12],w=n[13],b=n[14],T=n[15],e[12]=y*r+w*a+b*h+T*v,e[13]=y*i+w*l+b*d+T*p,e[14]=y*s+w*c+b*f+T*g,e[15]=y*o+w*u+b*m+T*x,e}var y=function(e,t,n,r,i){var s,o=1/Math.tan(t/2);return e[0]=o/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=o,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=i&&i!==1/0?(s=1/(r-i),e[10]=(i+r)*s,e[14]=2*i*r*s):(e[10]=-1,e[14]=-2*r),e},w=x;function b(e,t){const n=null!==e.uvs,r=null!==e.uv1s,i=null!==e.tangents,s=null!==e.colors;let o=1,a=1;return`\n\n  [[block]] struct Camera\n  {\n      projView: mat4x4<f32>;\n  };\n  [[group(0), binding(0)]] var<uniform> camera: Camera;\n\n  struct Model {\n      matrix: mat4x4<f32>;\n      invTr: mat4x4<f32>;\n  };\n  [[block]] struct Models\n  {\n      model: [[stride(128)]] array<Model, ${t}>;\n  };\n  [[group(1), binding(0)]] var<uniform> models: Models;\n\n  struct VertexOutput\n  {\n      [[builtin(position)]] position: vec4<f32>;\n      [[location(0)]] normal: vec3<f32>;\n      [[location(1)]] worldPos: vec3<f32>;\n      ${n?`[[location(${a+=1})]] uv: vec2<f32>; /* wgsl */`:""}\n      ${r?`[[location(${a+=1})]] uv1: vec2<f32>; /* wgsl */`:""}\n      ${i?`[[location(${a+=1})]] tangent: vec3<f32>;\n             [[location(${a+=1})]] bitangent: vec3<f32>; /* wgsl */`:""}\n      ${s?`[[location(${a+=1})]] color: vec4<f32>; /* wgsl */`:""}\n  };\n\n  [[stage(vertex)]]\n  fn main([[builtin(instance_index)]] instanceIndex : u32,\n          [[location(0)]] pos: vec3<f32>,\n          [[location(1)]] normal: vec3<f32>,\n          ${n?`[[location(${o+=1})]] uv: vec2<f32>, /* wgsl */`:""}\n          ${r?`[[location(${o+=1})]] uv1: vec2<f32>, /* wgsl */`:""}\n          ${i?`[[location(${o+=1})]] tangent: vec4<f32>, /* wgsl */`:""}\n          ${s?`[[location(${o+=1})]] color: vec4<f32>, /* wgsl */`:""}) -> VertexOutput\n  {\n      let model = models.model[instanceIndex];\n      var v: VertexOutput;\n      v.position = camera.projView * model.matrix * vec4<f32>(pos, 1.0);\n      v.normal = normalize((model.invTr * vec4<f32>(normal, 0.0)).xyz);\n      v.worldPos = (model.matrix * vec4<f32>(pos, 1.0)).xyz;\n      ${n?"v.uv = uv;":""}\n      ${r?"v.uv1 = uv1;":""}\n      ${i?"v.tangent = normalize((model.matrix * vec4<f32>(tangent.xyz, 0.0)).xyz);\n             v.bitangent = cross(v.normal, v.tangent) * tangent.w; /* wgsl */":""}\n      ${s?"v.color = color;":""}\n      return v;\n  }`}function T(e,t){const n=null!==e.uvs,r=null!==e.uv1s,i=null!==e.tangents,s=null!==e.colors,{baseColorTexture:o,metallicRoughnessTexture:a,metallicFactor:l,roughnessFactor:c}=t.pbrMetallicRoughness,{normalTexture:h,occlusionTexture:d,emissiveTexture:f}=t;let{baseColorFactor:m}=t.pbrMetallicRoughness;m=m||[1,1,1,1];let{emissiveFactor:v}=t;v=v||[0,0,0];const p=(null==o?void 0:o.texCoord)||"",g=(null==a?void 0:a.texCoord)||"",x=(null==h?void 0:h.texCoord)||"",y=(null==d?void 0:d.texCoord)||"",w=(null==f?void 0:f.texCoord)||"";let b=1;return`\n\n  [[block]] struct Camera\n  {\n      eye: vec3<f32>;\n  };\n  [[group(0), binding(1)]] var<uniform> camera: Camera;\n\n  ${o?"[[group(1), binding(1)]] var texSampler: sampler;\n         [[group(1), binding(2)]] var tex: texture_2d<f32>; /* wgsl */":""}\n  ${a?"[[group(1), binding(3)]] var metalRoughSampler: sampler;\n         [[group(1), binding(4)]] var metalRoughTex: texture_2d<f32>; /* wgsl */":""}\n  ${h?"[[group(1), binding(5)]] var normalSampler: sampler;\n         [[group(1), binding(6)]] var normalTex: texture_2d<f32>; /* wgsl */":""}\n  ${d?"[[group(1), binding(7)]] var occlusionSampler: sampler;\n         [[group(1), binding(8)]] var occlusionTex: texture_2d<f32>; /* wgsl */":""}\n  ${f?"[[group(1), binding(9)]] var emissiveSampler: sampler;\n         [[group(1), binding(10)]] var emissiveTex: texture_2d<f32>; /* wgsl */":""}\n\n  let pi: f32 = 3.141592653589793;\n\n  fn blinnPhong(color: vec3<f32>,\n           l: vec3<f32>,\n           v: vec3<f32>,\n           n: vec3<f32>) -> vec3<f32>\n  {\n      let specExp = 64.0;\n      let intensity = 0.5;\n      let ambient = 0.5;\n\n      let diffuse = max(dot(n, l), 0.0);\n      let specular = pow(max(dot(n, normalize(l + v)), 0.0), specExp);\n\n      return color * ((diffuse + specular) * intensity + ambient);\n  }\n\n  fn brdf(color: vec3<f32>,\n          metallic: f32,\n          roughness: f32,\n          l: vec3<f32>,\n          v: vec3<f32>,\n          n: vec3<f32>) -> vec3<f32>\n  {\n      let h = normalize(l + v);\n      let ndotl = clamp(dot(n, l), 0.0, 1.0);\n      let ndotv = abs(dot(n, v));\n      let ndoth = clamp(dot(n, h), 0.0, 1.0);\n      let vdoth = clamp(dot(v, h), 0.0, 1.0);\n\n      let f0 = vec3<f32>(0.04);\n      let diffuseColor = color * (1.0 - f0) * (1.0 - metallic);\n      let specularColor = mix(f0, color, metallic);\n\n      let reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n      let reflectance0 = specularColor;\n      let reflectance9 = vec3<f32>(clamp(reflectance * 25.0, 0.0, 1.0));\n      let f = reflectance0 + (reflectance9 - reflectance0) * pow(1.0 - vdoth, 5.0);\n\n      let r2 = roughness * roughness;\n      let r4 = r2 * r2;\n      let attenuationL = 2.0 * ndotl / (ndotl + sqrt(r4 + (1.0 - r4) * ndotl * ndotl));\n      let attenuationV = 2.0 * ndotv / (ndotv + sqrt(r4 + (1.0 - r4) * ndotv * ndotv));\n      let g = attenuationL * attenuationV;\n\n      let temp = ndoth * ndoth * (r2 - 1.0) + 1.0;\n      let d = r2 / (pi * temp * temp);\n\n      let diffuse = (1.0 - f) / pi * diffuseColor;\n      let specular = max(f * g * d / (4.0 * ndotl * ndotv), vec3<f32>(0.0));\n      let intensity = 2.5;\n      let ambient = 0.4;\n      return ndotl * (diffuse + specular) * intensity + color * ambient;\n  }\n\n  [[stage(fragment)]]\n  fn main([[location(0)]] vNormal: vec3<f32>,\n          [[location(1)]] worldPos: vec3<f32>,\n          ${n?`[[location(${b+=1})]] uv: vec2<f32>, /* wgsl */`:""}\n          ${r?`[[location(${b+=1})]] uv1: vec2<f32>, /* wgsl */`:""}\n          ${i?`[[location(${b+=1})]] tangent: vec3<f32>,\n                 [[location(${b+=1})]] bitangent: vec3<f32>, /* wgsl */`:""}\n          ${s?`[[location(${b+=1})]] vColor: vec4<f32>, /* wgsl */`:""}) -> [[location(0)]] vec4<f32>\n  {\n      let lightPos = vec3<f32>(200.0, 400.0, 300.0);\n\n      var color = vec4<f32>(${u(m[0])},\n                            ${u(m[1])},\n                            ${u(m[2])},\n                            ${u(m[3])});\n      ${o?`color = color * textureSample(tex, texSampler, uv${p}); /* wgsl */`:""}\n      ${s?"color = color * vColor;":""}\n\n      ${"MASK"===t.alphaMode?`if (color.a < ${u(t.alphaCutoff,.5)})\n             {\n               discard;\n             } /* wgsl */`:""}\n\n      var metallic: f32 = ${u(l)};\n      var roughness: f32 = ${u(c)};\n      ${a?`let metalRough = textureSample(metalRoughTex, metalRoughSampler, uv${g});\n             metallic = metallic * metalRough.b;\n             roughness = roughness * metalRough.g; /* wgsl */`:""}\n      roughness = clamp(roughness, 0.04, 1.0);\n\n      let lightDir = normalize(lightPos - worldPos);\n      let viewDir = normalize(camera.eye - worldPos);\n\n      ${h?`var normal = textureSample(normalTex, normalSampler, uv${x}).rgb;\n             normal = normal * 2.0 - 1.0;\n             normal.x = normal.x * ${u(h.scale)};\n             normal.y = normal.y * ${u(h.scale)};\n             normal = normal.x * tangent + normal.y * bitangent + normal.z * vNormal;\n             normal = normalize(normal); /* wgsl */`:"var normal = normalize(vNormal); /* wgsl */"}\n      ${t.doubleSided?"if (dot(normal, viewDir) < 0.0)\n             {\n               normal = -normal;\n             } /* wgsl */":""}\n\n      ${d?`var ao = textureSample(occlusionTex, occlusionSampler, uv${y}).r;\n             ao = 1.0 + ${u(d.strength)} * (ao - 1.0);\n             /* wgsl */`:"let ao = 1.0;"}\n      var emissive = vec3<f32>(${u(v[0])},\n                               ${u(v[1])},\n                               ${u(v[2])});\n      ${f?`emissive = emissive * textureSample(emissiveTex, emissiveSampler, uv${w}).rgb; /* wgsl */`:""}\n\n      return vec4<f32>(brdf(color.rgb, metallic, roughness, lightDir, viewDir, normal) * ao + emissive, color.a);\n  }`}class M{constructor(e,t){this.isTransparent=!1,this.vertexCount=e.vertexCount,this.indexFormat=e.indices instanceof Uint16Array?"uint16":"uint32",this.positions=h(e.positions,GPUBufferUsage.VERTEX,t),this.normals=h(e.normals,GPUBufferUsage.VERTEX,t),this.indices=e.indices?h(e.indices,GPUBufferUsage.INDEX,t):null,this.uvs=e.uvs?h(e.uvs,GPUBufferUsage.VERTEX,t):null,this.uv1s=e.uv1s?h(e.uv1s,GPUBufferUsage.VERTEX,t):null,this.tangents=e.tangents?h(e.tangents,GPUBufferUsage.VERTEX,t):null,this.colors=e.colors?h(e.colors,GPUBufferUsage.VERTEX,t):null}draw(e,t){e.setPipeline(this.pipeline),e.setVertexBuffer(0,this.positions),e.setVertexBuffer(1,this.normals);let n=2;this.uvs&&(e.setVertexBuffer(n,this.uvs),n+=1),this.uv1s&&(e.setVertexBuffer(n,this.uv1s),n+=1),this.tangents&&(e.setVertexBuffer(n,this.tangents),n+=1),this.colors&&(e.setVertexBuffer(n,this.colors),n+=1),e.setBindGroup(1,this.uniformBindGroup),this.indices?(e.setIndexBuffer(this.indices,this.indexFormat),e.drawIndexed(this.vertexCount,t)):e.draw(this.vertexCount,t)}destroy(){var e,t,n,r;null===(e=this.indices)||void 0===e||e.destroy(),this.positions.destroy(),this.normals.destroy(),null===(t=this.uvs)||void 0===t||t.destroy(),null===(n=this.uv1s)||void 0===n||n.destroy(),null===(r=this.tangents)||void 0===r||r.destroy()}}const E=n(),P=r(0,1,0);class ${constructor(e,t,n){this.radius=3,this.theta=0,this.phi=0,this.eye=r(0,0,3),this.view=p(),this.yfov=Math.PI/3,this.proj=p(),this.projView=p();const i=e.clientWidth/e.clientHeight;if(n){if(g(this.view,n.world),"perspective"===n.json.type){const{yfov:e,zfar:t,znear:r}=n.json.perspective;this.yfov=e,y(this.proj,e,i,r,t||1/0)}else y(this.proj,this.yfov,i,.001,1/0);w(this.projView,this.proj,this.view)}else{y(this.proj,this.yfov,i,.01,1/0),this.update();let t=!1;e.onmousedown=()=>{t=!0},e.onmouseup=()=>{t=!1},e.onmousemove=e=>{t&&(this.theta-=e.movementX/window.innerWidth*Math.PI*2,this.phi=c(this.phi-e.movementY/window.innerHeight*Math.PI,-Math.PI/2+.1,Math.PI/2-.1),this.update())},e.onwheel=e=>{this.radius=c(this.radius+.002*e.deltaY,.01,1/0),this.update()}}this.projViewBuffer=t.createBuffer({size:64,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.eyeBuffer=t.createBuffer({size:12,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.bindGroup=t.createBindGroup({layout:t.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{}},{binding:1,visibility:GPUShaderStage.FRAGMENT,buffer:{}}]}),entries:[{binding:0,resource:{buffer:this.projViewBuffer}},{binding:1,resource:{buffer:this.eyeBuffer}}]}),window.addEventListener("resize",(()=>{this.proj[0]=1/(Math.tan(this.yfov/2)*(e.clientWidth/e.clientHeight)),w(this.projView,this.proj,this.view)}))}update(){var t,n,i,s,o,a;this.eye=r(0,0,this.radius),t=this.eye,n=this.eye,i=E,s=this.phi,a=[],(o=[])[0]=n[0]-i[0],o[1]=n[1]-i[1],o[2]=n[2]-i[2],a[0]=o[0],a[1]=o[1]*Math.cos(s)-o[2]*Math.sin(s),a[2]=o[1]*Math.sin(s)+o[2]*Math.cos(s),t[0]=a[0]+i[0],t[1]=a[1]+i[1],t[2]=a[2]+i[2],function(e,t,n,r){var i=[],s=[];i[0]=t[0]-n[0],i[1]=t[1]-n[1],i[2]=t[2]-n[2],s[0]=i[2]*Math.sin(r)+i[0]*Math.cos(r),s[1]=i[1],s[2]=i[2]*Math.cos(r)-i[0]*Math.sin(r),e[0]=s[0]+n[0],e[1]=s[1]+n[1],e[2]=s[2]+n[2]}(this.eye,this.eye,E,this.theta),function(t,n,r,i){var s,o,a,l,c,u,h,d,f,m,v=n[0],p=n[1],g=n[2],x=i[0],y=i[1],w=i[2],b=r[0],T=r[1],M=r[2];Math.abs(v-b)<e&&Math.abs(p-T)<e&&Math.abs(g-M)<e?function(e){e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1}(t):(h=v-b,d=p-T,f=g-M,s=y*(f*=m=1/Math.hypot(h,d,f))-w*(d*=m),o=w*(h*=m)-x*f,a=x*d-y*h,(m=Math.hypot(s,o,a))?(s*=m=1/m,o*=m,a*=m):(s=0,o=0,a=0),l=d*a-f*o,c=f*s-h*a,u=h*o-d*s,(m=Math.hypot(l,c,u))?(l*=m=1/m,c*=m,u*=m):(l=0,c=0,u=0),t[0]=s,t[1]=l,t[2]=h,t[3]=0,t[4]=o,t[5]=c,t[6]=d,t[7]=0,t[8]=a,t[9]=u,t[10]=f,t[11]=0,t[12]=-(s*v+o*p+a*g),t[13]=-(l*v+c*p+u*g),t[14]=-(h*v+d*p+f*g),t[15]=1)}(this.view,this.eye,E,P),w(this.projView,this.proj,this.view)}bind(e,t){const n=this.projView;e.queue.writeBuffer(this.projViewBuffer,0,n.buffer,n.byteOffset,n.byteLength);const r=this.eye;e.queue.writeBuffer(this.eyeBuffer,0,r.buffer,r.byteOffset,r.byteLength),t.setBindGroup(0,this.bindGroup)}destroy(){this.projViewBuffer.destroy(),this.eyeBuffer.destroy()}}class U{constructor(e,n,r,i,s){this.meshes={},this.textures={},this.cameras=[],this.camera=new $(r,i);const o=(n,r=p())=>{var s;const a=(l=r,(c=new t(16))[0]=l[0],c[1]=l[1],c[2]=l[2],c[3]=l[3],c[4]=l[4],c[5]=l[5],c[6]=l[6],c[7]=l[7],c[8]=l[8],c[9]=l[9],c[10]=l[10],c[11]=l[11],c[12]=l[12],c[13]=l[13],c[14]=l[14],c[15]=l[15],c);var l,c;if(n.matrix)x(a,a,n.matrix);else{if(n.translation&&function(e,t,n){var r,i,s,o,a,l,c,u,h,d,f,m,v=n[0],p=n[1],g=n[2];t===e?(e[12]=t[0]*v+t[4]*p+t[8]*g+t[12],e[13]=t[1]*v+t[5]*p+t[9]*g+t[13],e[14]=t[2]*v+t[6]*p+t[10]*g+t[14],e[15]=t[3]*v+t[7]*p+t[11]*g+t[15]):(r=t[0],i=t[1],s=t[2],o=t[3],a=t[4],l=t[5],c=t[6],u=t[7],h=t[8],d=t[9],f=t[10],m=t[11],e[0]=r,e[1]=i,e[2]=s,e[3]=o,e[4]=a,e[5]=l,e[6]=c,e[7]=u,e[8]=h,e[9]=d,e[10]=f,e[11]=m,e[12]=r*v+a*p+h*g+t[12],e[13]=i*v+l*p+d*g+t[13],e[14]=s*v+c*p+f*g+t[14],e[15]=o*v+u*p+m*g+t[15])}(a,a,n.translation),n.rotation){const e=p();!function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=n+n,a=r+r,l=i+i,c=n*o,u=r*o,h=r*a,d=i*o,f=i*a,m=i*l,v=s*o,p=s*a,g=s*l;e[0]=1-h-m,e[1]=u+g,e[2]=d-p,e[3]=0,e[4]=u-g,e[5]=1-c-m,e[6]=f+v,e[7]=0,e[8]=d+p,e[9]=f-v,e[10]=1-c-h,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1}(e,n.rotation),x(a,a,e)}n.scale&&function(e,t,n){var r=n[0],i=n[1],s=n[2];e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e[4]=t[4]*i,e[5]=t[5]*i,e[6]=t[6]*i,e[7]=t[7]*i,e[8]=t[8]*s,e[9]=t[9]*s,e[10]=t[10]*s,e[11]=t[11]*s,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]}(a,a,n.scale)}if(void 0!==n.mesh){const t=p();g(t,a),function(e,t){if(e===t){var n=t[1],r=t[2],i=t[3],s=t[6],o=t[7],a=t[11];e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=n,e[6]=t[9],e[7]=t[13],e[8]=r,e[9]=s,e[11]=t[14],e[12]=i,e[13]=o,e[14]=a}else e[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15]}(t,t),this.meshes[n.mesh]?(this.meshes[n.mesh].matrices.push(a),this.meshes[n.mesh].matrices.push(t)):this.meshes[n.mesh]={matrices:[a,t],matrixBuffer:void 0,primitives:e.meshes[n.mesh].map((e=>new M(e,i)))}}void 0!==n.camera&&this.cameras.push({world:a,json:e.cameras[n.camera]}),null===(s=n.children)||void 0===s||s.forEach((t=>o(e.nodes[t],a)))};e.scenes[n].nodes.forEach((t=>{o(e.nodes[t])})),Object.entries(this.meshes).forEach((([t,n])=>{n.matrixBuffer=h(function(e){let t=0;e.forEach((e=>{t+=e.length}));const n=new Float32Array(t);return t=0,e.forEach((e=>{n.set(e,t),t+=e.length})),n}(n.matrices),GPUBufferUsage.UNIFORM,i),n.primitives.forEach(((r,o)=>{const{material:a}=e.meshes[Number(t)][o],{baseColorTexture:l,metallicRoughnessTexture:c}=a.pbrMetallicRoughness,{normalTexture:u,occlusionTexture:h,emissiveTexture:d}=a,f=[l,c,u,h,d];r.isTransparent="BLEND"===a.alphaMode,f.forEach((t=>{if(t&&!this.textures[t.index]){const{width:n,height:r}=e.textures[t.index].source;this.textures[t.index]=i.createTexture({size:[n,r,1],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT}),i.queue.copyExternalImageToTexture({source:e.textures[t.index].source},{texture:this.textures[t.index]},[n,r])}})),r.pipeline=function(e,t,n,r,i){const{baseColorTexture:s,metallicRoughnessTexture:o}=n.pbrMetallicRoughness,{normalTexture:a,occlusionTexture:l,emissiveTexture:c}=n,u=[s,o,a,l,c];let h=-1;function d(e){return h+=1,{attributes:[{shaderLocation:h,offset:0,format:`float32x${e}`}],arrayStride:4*e}}const f=[d(3),d(3)];null!==r.uvs&&f.push(d(2)),null!==r.uv1s&&f.push(d(2)),null!==r.tangents&&f.push(d(4)),null!==r.colors&&f.push(d(4));const m=[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{}}];return u.forEach(((e,t)=>{e&&(m.push({binding:2*t+1,visibility:GPUShaderStage.FRAGMENT,sampler:{}}),m.push({binding:2*t+2,visibility:GPUShaderStage.FRAGMENT,texture:{}}))})),e.createRenderPipeline({layout:e.createPipelineLayout({bindGroupLayouts:[e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{}},{binding:1,visibility:GPUShaderStage.FRAGMENT,buffer:{}}]}),e.createBindGroupLayout({entries:m})]}),vertex:{module:e.createShaderModule({code:b(r,i)}),entryPoint:"main",buffers:f},fragment:{module:e.createShaderModule({code:T(r,n)}),entryPoint:"main",targets:[{format:t,blend:{color:"BLEND"!==n.alphaMode?{operation:"add",srcFactor:"one",dstFactor:"zero"}:{operation:"add",srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{operation:"add",srcFactor:"zero",dstFactor:"one"}}}]},primitive:{topology:"triangle-list",cullMode:n.doubleSided?"none":"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus"}})}(i,s,a,r,n.matrices.length/2);const m=[{binding:0,resource:{buffer:n.matrixBuffer}}];f.forEach(((t,n)=>{if(t){const{addressModeU:r,addressModeV:s,magFilter:o,minFilter:a}=e.textures[t.index].sampler;m.push({binding:2*n+1,resource:i.createSampler({addressModeU:r,addressModeV:s,magFilter:o,minFilter:a})}),m.push({binding:2*n+2,resource:this.textures[t.index].createView()})}})),r.uniformBindGroup=i.createBindGroup({layout:r.pipeline.getBindGroupLayout(1),entries:m})}))}))}destroy(){this.camera.destroy(),Object.entries(this.meshes).forEach((([,e])=>{e.matrixBuffer.destroy(),e.primitives.forEach((e=>{e.destroy()}))})),Object.entries(this.textures).forEach((([,e])=>e.destroy()))}}var R=function(e,t,n,r){return new(n||(n=Promise))((function(i,s){function o(e){try{l(r.next(e))}catch(e){s(e)}}function a(e){try{l(r.throw(e))}catch(e){s(e)}}function l(e){var t;e.done?i(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(o,a)}l((r=r.apply(e,t||[])).next())}))};class A{constructor(e,t,n,r){this.canvas=e,this.device=t,this.context=n,this.contextFormat=r;let i=t.createTexture({size:[e.clientWidth*devicePixelRatio,e.clientHeight*devicePixelRatio],format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT});this.renderPassDesc={colorAttachments:[],depthStencilAttachment:{view:i.createView(),depthLoadValue:1,depthStoreOp:"store",stencilLoadValue:0,stencilStoreOp:"store"}},window.addEventListener("resize",(()=>{const s=[e.clientWidth*devicePixelRatio,e.clientHeight*devicePixelRatio];n.configure({device:t,format:r,size:s}),i.destroy(),i=t.createTexture({size:s,format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT}),this.renderPassDesc.depthStencilAttachment.view=i.createView()}))}render(){const e=()=>{const t=this.device.createCommandEncoder();this.renderPassDesc.colorAttachments=[{view:this.context.getCurrentTexture().createView(),loadValue:{r:.3,g:.5,b:.7,a:1},storeOp:"store"}];const n=t.beginRenderPass(this.renderPassDesc);this.scene.camera.bind(this.device,n),Object.entries(this.scene.meshes).forEach((([,e])=>{e.primitives.forEach((t=>{t.isTransparent||t.draw(n,e.matrices.length/2)}))})),Object.entries(this.scene.meshes).forEach((([,e])=>{e.primitives.forEach((t=>{t.isTransparent&&t.draw(n,e.matrices.length/2)}))})),n.endPass(),this.device.queue.submit([t.finish()]),requestAnimationFrame(e)};requestAnimationFrame(e)}load(e){var t;return R(this,void 0,void 0,(function*(){this.gltf=yield function(e){return m(this,void 0,void 0,(function*(){const t=e.substring(0,e.lastIndexOf("/")),n=yield function(e){return new Promise((t=>{const n=new XMLHttpRequest;n.overrideMimeType("application/json"),n.open("GET",e),n.onreadystatechange=()=>{4===n.readyState&&200===n.status&&t(JSON.parse(n.responseText))},n.send(null)}))}(e);let r;const i=Promise.all(n.buffers.map((e=>function(e){return new Promise((t=>{const n=new XMLHttpRequest;n.responseType="arraybuffer",n.open("GET",e),n.onreadystatechange=()=>{4===n.readyState&&200===n.status&&t(n.response)},n.send(null)}))}(`${t}/${e.uri}`)))).then((e=>{r=function(e,t){return e.meshes.map((n=>n.primitives.map((n=>new f(e,n,t)))))}(n,e)})),s=[];let o=Promise.resolve();return n.images&&(o=Promise.all(n.images.map(((e,n)=>function(e){return m(this,void 0,void 0,(function*(){const t=new Image;return t.crossOrigin="Anonymous",t.src=e,yield t.decode(),createImageBitmap(t)}))}(`${t}/${e.uri}`).then((e=>{s[n]=e})))))),Promise.all([i,o]).then((()=>new v(n,r,s)))}))}(e),null===(t=this.scene)||void 0===t||t.destroy(),this.scene=new U(this.gltf,this.gltf.scene||0,this.canvas,this.device,this.contextFormat),this.render()}))}getCameraCount(){return this.scene?this.scene.cameras.length:0}setCamera(e){var t;null===(t=this.scene)||void 0===t||t.camera.destroy(),this.scene&&(this.scene.camera=new $(this.canvas,this.device,void 0!==e?this.scene.cameras[e]:void 0))}}var C=function(e,t,n,r){return new(n||(n=Promise))((function(i,s){function o(e){try{l(r.next(e))}catch(e){s(e)}}function a(e){try{l(r.throw(e))}catch(e){s(e)}}function l(e){var t;e.done?i(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(o,a)}l((r=r.apply(e,t||[])).next())}))};const S=document.getElementById("webgpu-canvas"),B=document.getElementById("model-select"),G=document.getElementById("camera-select"),F=document.createElement("option");F.innerHTML="User Camera",F.value="User Camera",fetch("https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/model-index.json").then((e=>e.json())).then((e=>{e.forEach((e=>C(void 0,void 0,void 0,(function*(){const t=document.createElement("option");if(t.innerHTML=e.name,t.value=`https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/${e.name}/glTF/${e.name}.gltf`,B.add(t),"DamagedHelmet"===e.name){B.value=t.value;const e=yield function(e){return R(this,void 0,void 0,(function*(){const t=navigator.gpu;if(!t)throw new Error("WebGPU is not supported on this browser.");const n=yield t.requestAdapter(),r=yield n.requestDevice(),i=e.getContext("webgpu"),s=i.getPreferredFormat(n);return i.configure({device:r,format:s,size:[e.clientWidth*devicePixelRatio,e.clientHeight*devicePixelRatio]}),new A(e,r,i,s)}))}(S),n=()=>C(void 0,void 0,void 0,(function*(){yield e.load(B.value),G.innerHTML="",G.add(F);for(let t=0;t<e.getCameraCount();t+=1){const e=document.createElement("option");e.innerHTML=String(t),e.value=String(t),G.add(e)}}));n(),B.onchange=()=>n(),G.onchange=()=>e.setCamera("User Camera"!==G.value?Number(G.value):void 0)}}))))}))})();