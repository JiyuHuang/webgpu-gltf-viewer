(()=>{var e={466:function(e){var t;e.exports=((t=function(){function e(e){return i.appendChild(e.dom),e}function n(e){for(var t=0;t<i.children.length;t++)i.children[t].style.display=t===e?"block":"none";r=e}var r=0,i=document.createElement("div");i.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",i.addEventListener("click",(function(e){e.preventDefault(),n(++r%i.children.length)}),!1);var o=(performance||Date).now(),s=o,a=0,l=e(new t.Panel("FPS","#0ff","#002")),c=e(new t.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var u=e(new t.Panel("MB","#f08","#201"));return n(0),{REVISION:16,dom:i,addPanel:e,showPanel:n,begin:function(){o=(performance||Date).now()},end:function(){a++;var e=(performance||Date).now();if(c.update(e-o,200),e>s+1e3&&(l.update(1e3*a/(e-s),100),s=e,a=0,u)){var t=performance.memory;u.update(t.usedJSHeapSize/1048576,t.jsHeapSizeLimit/1048576)}return e},update:function(){o=this.end()},domElement:i,setMode:n}}).Panel=function(e,t,n){var r=1/0,i=0,o=Math.round,s=o(window.devicePixelRatio||1),a=80*s,l=48*s,c=3*s,u=2*s,d=3*s,f=15*s,h=74*s,m=30*s,v=document.createElement("canvas");v.width=a,v.height=l,v.style.cssText="width:80px;height:48px";var p=v.getContext("2d");return p.font="bold "+9*s+"px Helvetica,Arial,sans-serif",p.textBaseline="top",p.fillStyle=n,p.fillRect(0,0,a,l),p.fillStyle=t,p.fillText(e,c,u),p.fillRect(d,f,h,m),p.fillStyle=n,p.globalAlpha=.9,p.fillRect(d,f,h,m),{dom:v,update:function(l,g){r=Math.min(r,l),i=Math.max(i,l),p.fillStyle=n,p.globalAlpha=1,p.fillRect(0,0,a,f),p.fillStyle=t,p.fillText(o(l)+" "+e+" ("+o(r)+"-"+o(i)+")",c,u),p.drawImage(v,d+s,f,h-s,m,d,f,h-s,m),p.fillRect(d+h-s,f,s,m),p.fillStyle=n,p.globalAlpha=.9,p.fillRect(d+h-s,f,s,o((1-l/g)*m))}}},t)}},t={};function n(r){var i=t[r];if(void 0!==i)return i.exports;var o=t[r]={exports:{}};return e[r].call(o.exports,o,o.exports,n),o.exports}(()=>{"use strict";var e=1e-6,t="undefined"!=typeof Float32Array?Float32Array:Array;function r(){var e=new t(3);return t!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function i(e,n,r){var i=new t(3);return i[0]=e,i[1]=n,i[2]=r,i}function o(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e}function s(e,t){var n=t[0],r=t[1],i=t[2],o=n*n+r*r+i*i;return o>0&&(o=1/Math.sqrt(o)),e[0]=t[0]*o,e[1]=t[1]*o,e[2]=t[2]*o,e}Math.random,Math.PI,Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});var a=function(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e};function l(){var e=new t(2);return t!=Float32Array&&(e[0]=0,e[1]=0),e}r();var c=function(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e};function u(e,t,n){return Math.min(Math.max(e,t),n)}function d(e,t=1){const n=void 0!==e?e:t;return Number.isInteger(n)?`${n}.0`:n}function f(e){return new Promise((t=>{const n=new XMLHttpRequest;n.responseType="arraybuffer",n.open("GET",e),n.onreadystatechange=()=>{4===n.readyState&&200===n.status&&t(n.response)},n.send(null)}))}function h(e,t,n){const r=n.createBuffer({size:e.byteLength+3&-4,usage:t,mappedAtCreation:!0});let i;return i=e instanceof Int8Array?new Int8Array(r.getMappedRange()):e instanceof Uint8Array?new Uint8Array(r.getMappedRange()):e instanceof Int16Array?new Int16Array(r.getMappedRange()):e instanceof Uint16Array?new Uint16Array(r.getMappedRange()):e instanceof Uint32Array?new Uint32Array(r.getMappedRange()):new Float32Array(r.getMappedRange()),i.set(e),r.unmap(),r}function m(e){const{baseColorTexture:t,metallicRoughnessTexture:n}=e.pbrMetallicRoughness,{normalTexture:r,occlusionTexture:i,emissiveTexture:o}=e;return[t,n,r,i,o]}l();const v={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16,9728:"nearest",9729:"linear",9984:"linear",9985:"linear",9986:"linear",9987:"linear",33071:"clamp-to-edge",33648:"mirror-repeat",10497:"repeat"};var p=function(e,t,n,r){return new(n||(n=Promise))((function(i,o){function s(e){try{l(r.next(e))}catch(e){o(e)}}function a(e){try{l(r.throw(e))}catch(e){o(e)}}function l(e){var t;e.done?i(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(s,a)}l((r=r.apply(e,t||[])).next())}))};class g{constructor(e,n,u,d=0){function f(e){return{magFilter:v[e.magFilter||9729],minFilter:v[e.minFilter||9729],addressModeU:v[e.wrapS||10497],addressModeV:v[e.wrapT||10497]}}this.scenes=e.scenes,this.defaultScene=e.scene||0,this.nodes=e.nodes,this.cameras=e.cameras||null,this.images=u;const h=e.samplers?e.samplers.map((e=>f(e))):[],p=f({}),g=e.textures?e.textures.map((e=>(e.sampler=void 0!==e.sampler?h[e.sampler]:p,e))):[],y=e.materials?e.materials.map((e=>(e.pbrMetallicRoughness||(e.pbrMetallicRoughness={}),m(e).forEach((e=>{e&&(e.source=g[e.index].source,e.sampler=g[e.index].sampler)})),e))):[],w={pbrMetallicRoughness:{}},x=e.accessors.map((t=>{const r=v[t.type],i=e.bufferViews[t.bufferView],o=(i.byteOffset||0)+(t.byteOffset||0);let s=i.byteStride/4;s=s>r?s:r;const a=function(e,t,n,r){switch(e){case 5120:return new Int8Array(t,n,r);case 5121:return new Uint8Array(t,n,r);case 5122:return new Int16Array(t,n,r);case 5123:return new Uint16Array(t,n,r);case 5125:return new Uint32Array(t,n,r);case 5126:return new Float32Array(t,n,r);default:throw new Error("invalid component type")}}(t.componentType,n[i.buffer],0===i.buffer?o+d:o,(t.count-1)*s+r);if(s>r){const e=new(0,a.constructor)(t.count*r);for(let t=0,n=0;t<e.length;t+=r,n+=s)for(let i=0;i<r;i+=1)e[t+i]=a[n+i];return e}return a}));this.meshes=e.meshes.map((n=>n.primitives.map((n=>{const u=void 0!==n.material?y[n.material]:w;let d,f=null;void 0!==n.indices?(f=function(e){if(e instanceof Uint16Array||e instanceof Uint32Array)return e;let t;return t=e instanceof Float32Array?new Uint32Array(e.length):new Uint16Array(e.length),e.forEach(((e,n)=>{t[n]=e})),t}(x[n.indices]),d=e.accessors[n.indices].count):d=e.accessors[n.attributes.POSITION].count;const h=x[n.attributes.POSITION],{max:m,min:v}=e.accessors[n.attributes.POSITION],p={max:m,min:v};let g;g=void 0!==n.attributes.NORMAL?x[n.attributes.NORMAL]:function(e,t){const n=new Float32Array(t.length),o=e?e.length:t.length;for(let g=0;g<o;g+=3){const o=[];for(let t=0;t<3;t+=1)e?o.push(e[g+t]):o.push(g+t);const y=o.map((e=>{const n=3*e;return i(t[n],t[n+1],t[n+2])})),w=r();a(w,y[1],y[0]);const x=r();a(x,y[2],y[0]);const b=r();l=b,c=s(w,w),u=s(w,x),void 0,void 0,void 0,void 0,void 0,void 0,d=c[0],f=c[1],h=c[2],m=u[0],v=u[1],p=u[2],l[0]=f*p-h*v,l[1]=h*m-d*p,l[2]=d*v-f*m;for(let e=0;e<3;e+=1){const t=3*(g+e);for(let e=0;e<3;e+=1)n[t+e]+=b[e]}}var l,c,u,d,f,h,m,v,p;return n}(f,h);let b=null;void 0!==n.attributes.TEXCOORD_0&&(b=x[n.attributes.TEXCOORD_0]);let T=null;void 0!==n.attributes.TEXCOORD_1&&(T=x[n.attributes.TEXCOORD_1]);let M=null;void 0!==n.attributes.TANGENT&&void 0!==n.attributes.NORMAL?M=x[n.attributes.TANGENT]:u.normalTexture&&(M=function(e,n,u,d){const f=new Float32Array(u.length/3*4),h=e?e.length:n.length;for(let u=0;u<h;u+=3){const h=[];for(let t=0;t<3;t+=1)e?h.push(e[u+t]):h.push(u+t);const m=h.map((e=>{const t=3*e;return i(n[t],n[t+1],n[t+2])})),v=h.map((e=>{const n=2*e;return r=d[n],i=d[n+1],(o=new t(2))[0]=r,o[1]=i,o;var r,i,o})),p=r();a(p,m[1],m[0]);const g=r();a(g,m[2],m[0]);const y=l();c(y,v[1],v[0]);const w=l();c(w,v[2],v[0]);const x=w[1]*y[0]-y[1]*w[0]>=0?1:-1,b=r();a(b,o(p,p,w[1]),o(g,g,y[1])),s(b,b);for(let e=0;e<3;e+=1){const t=4*(u+e);for(let e=0;e<3;e+=1)f[t+e]+=b[e];f[t+3]=x}}return f}(f,h,g,b));let E=null;return void 0!==n.attributes.COLOR_0&&(E=x[n.attributes.COLOR_0]),{vertexCount:d,indices:f,positions:h,normals:g,uvs:b,uv1s:T,tangents:M,colors:E,material:u,boundingBox:p}}))))}}function y(e,t,n,r=0){return p(this,void 0,void 0,(function*(){const i=t.substring(0,t.lastIndexOf("/")),o=[];let s=Promise.resolve();e.images&&(s=Promise.all(e.images.map(((e,t)=>p(this,void 0,void 0,(function*(){if(e.uri){const n=new Image;n.crossOrigin="Anonymous",n.src=`${i}/${e.uri}`,yield n.decode(),o[t]=yield createImageBitmap(n,{colorSpaceConversion:"none"})}}))))));const a=[];yield Promise.all(e.buffers.map(((e,t)=>{if(!e.uri){if(0!==t)throw new Error("buffer uri undefined");return a[t]=n,Promise.resolve()}return f(`${i}/${e.uri}`).then((e=>{a[t]=e}))})));let l=Promise.resolve();return e.images&&(l=Promise.all(e.images.map(((t,n)=>p(this,void 0,void 0,(function*(){if(void 0!==t.bufferView){const{buffer:i,byteOffset:s,byteLength:l}=e.bufferViews[t.bufferView],c=new Uint8Array(a[i],0===i?s+r:s,l);let u;u=t.mimeType?t.mimeType:255===c[0]?"image/jpeg":"image/png";const d=new Blob([c],{type:u});o[n]=yield createImageBitmap(d,{colorSpaceConversion:"none"})}})))))),yield Promise.all([s,l]),new g(e,a,o,r)}))}function w(){var e=new t(16);return t!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function x(e,t){var n=t[0],r=t[1],i=t[2],o=t[3],s=t[4],a=t[5],l=t[6],c=t[7],u=t[8],d=t[9],f=t[10],h=t[11],m=t[12],v=t[13],p=t[14],g=t[15],y=n*a-r*s,w=n*l-i*s,x=n*c-o*s,b=r*l-i*a,T=r*c-o*a,M=i*c-o*l,E=u*v-d*m,P=u*p-f*m,S=u*g-h*m,R=d*p-f*v,U=d*g-h*v,A=f*g-h*p,$=y*A-w*U+x*R+b*S-T*P+M*E;return $?($=1/$,e[0]=(a*A-l*U+c*R)*$,e[1]=(i*U-r*A-o*R)*$,e[2]=(v*M-p*T+g*b)*$,e[3]=(f*T-d*M-h*b)*$,e[4]=(l*S-s*A-c*P)*$,e[5]=(n*A-i*S+o*P)*$,e[6]=(p*x-m*M-g*w)*$,e[7]=(u*M-f*x+h*w)*$,e[8]=(s*U-a*S+c*E)*$,e[9]=(r*S-n*U-o*E)*$,e[10]=(m*T-v*x+g*y)*$,e[11]=(d*x-u*T-h*y)*$,e[12]=(a*P-s*R-l*E)*$,e[13]=(n*R-r*P+i*E)*$,e[14]=(v*w-m*b-p*y)*$,e[15]=(u*b-d*w+f*y)*$,e):null}function b(e,t,n){var r=t[0],i=t[1],o=t[2],s=t[3],a=t[4],l=t[5],c=t[6],u=t[7],d=t[8],f=t[9],h=t[10],m=t[11],v=t[12],p=t[13],g=t[14],y=t[15],w=n[0],x=n[1],b=n[2],T=n[3];return e[0]=w*r+x*a+b*d+T*v,e[1]=w*i+x*l+b*f+T*p,e[2]=w*o+x*c+b*h+T*g,e[3]=w*s+x*u+b*m+T*y,w=n[4],x=n[5],b=n[6],T=n[7],e[4]=w*r+x*a+b*d+T*v,e[5]=w*i+x*l+b*f+T*p,e[6]=w*o+x*c+b*h+T*g,e[7]=w*s+x*u+b*m+T*y,w=n[8],x=n[9],b=n[10],T=n[11],e[8]=w*r+x*a+b*d+T*v,e[9]=w*i+x*l+b*f+T*p,e[10]=w*o+x*c+b*h+T*g,e[11]=w*s+x*u+b*m+T*y,w=n[12],x=n[13],b=n[14],T=n[15],e[12]=w*r+x*a+b*d+T*v,e[13]=w*i+x*l+b*f+T*p,e[14]=w*o+x*c+b*h+T*g,e[15]=w*s+x*u+b*m+T*y,e}var T=function(e,t,n,r,i){var o,s=1/Math.tan(t/2);return e[0]=s/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=s,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=i&&i!==1/0?(o=1/(r-i),e[10]=(i+r)*o,e[14]=2*i*r*o):(e[10]=-1,e[14]=-2*r),e},M=b;function E(e,t){const n=null!==e.uvs,r=null!==e.uv1s,i=null!==e.tangents,o=null!==e.colors;let s=1,a=1;return`\n\n  [[block]] struct Camera\n  {\n      projView: mat4x4<f32>;\n  };\n  [[group(0), binding(0)]] var<uniform> camera: Camera;\n\n  struct Model {\n      matrix: mat4x4<f32>;\n      invTr: mat4x4<f32>;\n  };\n  [[block]] struct Models\n  {\n      model: [[stride(128)]] array<Model, ${t}>;\n  };\n  [[group(1), binding(0)]] var<uniform> models: Models;\n\n  struct VertexOutput\n  {\n      [[builtin(position)]] position: vec4<f32>;\n      [[location(0)]] normal: vec3<f32>;\n      [[location(1)]] worldPos: vec3<f32>;\n      ${n?`[[location(${a+=1})]] uv: vec2<f32>; /* wgsl */`:""}\n      ${r?`[[location(${a+=1})]] uv1: vec2<f32>; /* wgsl */`:""}\n      ${i?`[[location(${a+=1})]] tangent: vec3<f32>;\n             [[location(${a+=1})]] bitangent: vec3<f32>; /* wgsl */`:""}\n      ${o?`[[location(${a+=1})]] color: vec4<f32>; /* wgsl */`:""}\n  };\n\n  [[stage(vertex)]]\n  fn main([[builtin(instance_index)]] instanceIndex : u32,\n          [[location(0)]] pos: vec3<f32>,\n          [[location(1)]] normal: vec3<f32>,\n          ${n?`[[location(${s+=1})]] uv: vec2<f32>, /* wgsl */`:""}\n          ${r?`[[location(${s+=1})]] uv1: vec2<f32>, /* wgsl */`:""}\n          ${i?`[[location(${s+=1})]] tangent: vec4<f32>, /* wgsl */`:""}\n          ${o?`[[location(${s+=1})]] color: vec4<f32>, /* wgsl */`:""}) -> VertexOutput\n  {\n      let model = models.model[instanceIndex];\n      var v: VertexOutput;\n      v.position = camera.projView * model.matrix * vec4<f32>(pos, 1.0);\n      v.normal = normalize((model.invTr * vec4<f32>(normal, 0.0)).xyz);\n      v.worldPos = (model.matrix * vec4<f32>(pos, 1.0)).xyz;\n      ${n?"v.uv = uv;":""}\n      ${r?"v.uv1 = uv1;":""}\n      ${i?"v.tangent = normalize((model.matrix * vec4<f32>(tangent.xyz, 0.0)).xyz);\n             v.bitangent = cross(v.normal, v.tangent) * tangent.w; /* wgsl */":""}\n      ${o?"v.color = color;":""}\n      return v;\n  }`}function P(e,t){const n=null!==e.uvs,r=null!==e.uv1s,i=null!==e.tangents,o=null!==e.colors,{baseColorTexture:s,metallicRoughnessTexture:a,metallicFactor:l,roughnessFactor:c}=t.pbrMetallicRoughness,{normalTexture:u,occlusionTexture:f,emissiveTexture:h}=t;let{baseColorFactor:m}=t.pbrMetallicRoughness;m=m||[1,1,1,1];let{emissiveFactor:v}=t;v=v||[0,0,0];const p=(null==s?void 0:s.texCoord)||"",g=(null==a?void 0:a.texCoord)||"",y=(null==u?void 0:u.texCoord)||"",w=(null==f?void 0:f.texCoord)||"",x=(null==h?void 0:h.texCoord)||"";let b=1;return`\n\n  [[block]] struct Camera\n  {\n      eye: vec3<f32>;\n  };\n  [[group(0), binding(1)]] var<uniform> camera: Camera;\n\n  ${s?"[[group(1), binding(1)]] var texSampler: sampler;\n         [[group(1), binding(2)]] var tex: texture_2d<f32>; /* wgsl */":""}\n  ${a?"[[group(1), binding(3)]] var metalRoughSampler: sampler;\n         [[group(1), binding(4)]] var metalRoughTex: texture_2d<f32>; /* wgsl */":""}\n  ${u?"[[group(1), binding(5)]] var normalSampler: sampler;\n         [[group(1), binding(6)]] var normalTex: texture_2d<f32>; /* wgsl */":""}\n  ${f?"[[group(1), binding(7)]] var occlusionSampler: sampler;\n         [[group(1), binding(8)]] var occlusionTex: texture_2d<f32>; /* wgsl */":""}\n  ${h?"[[group(1), binding(9)]] var emissiveSampler: sampler;\n         [[group(1), binding(10)]] var emissiveTex: texture_2d<f32>; /* wgsl */":""}\n\n  fn linearSample(texture: texture_2d<f32>, texSampler: sampler, uv: vec2<f32>) -> vec4<f32>\n  {\n    let color = textureSample(texture, texSampler, uv);\n    return vec4<f32>(pow(color.rgb, vec3<f32>(2.2)), color.a);\n  }\n\n  let pi: f32 = 3.141592653589793;\n\n  fn blinnPhong(color: vec3<f32>,\n           l: vec3<f32>,\n           v: vec3<f32>,\n           n: vec3<f32>) -> vec3<f32>\n  {\n      let specExp = 64.0;\n      let intensity = 0.5;\n      let ambient = 0.5;\n\n      let diffuse = max(dot(n, l), 0.0);\n      let specular = pow(max(dot(n, normalize(l + v)), 0.0), specExp);\n\n      return color * ((diffuse + specular) * intensity + ambient);\n  }\n\n  fn brdf(color: vec3<f32>,\n          metallic: f32,\n          roughness: f32,\n          l: vec3<f32>,\n          v: vec3<f32>,\n          n: vec3<f32>) -> vec3<f32>\n  {\n      let h = normalize(l + v);\n      let ndotl = clamp(dot(n, l), 0.0, 1.0);\n      let ndotv = abs(dot(n, v));\n      let ndoth = clamp(dot(n, h), 0.0, 1.0);\n      let vdoth = clamp(dot(v, h), 0.0, 1.0);\n\n      let f0 = vec3<f32>(0.04);\n      let diffuseColor = color * (1.0 - f0) * (1.0 - metallic);\n      let specularColor = mix(f0, color, metallic);\n\n      let reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n      let reflectance0 = specularColor;\n      let reflectance9 = vec3<f32>(clamp(reflectance * 25.0, 0.0, 1.0));\n      let f = reflectance0 + (reflectance9 - reflectance0) * pow(1.0 - vdoth, 5.0);\n\n      let r2 = roughness * roughness;\n      let r4 = r2 * r2;\n      let attenuationL = 2.0 * ndotl / (ndotl + sqrt(r4 + (1.0 - r4) * ndotl * ndotl));\n      let attenuationV = 2.0 * ndotv / (ndotv + sqrt(r4 + (1.0 - r4) * ndotv * ndotv));\n      let g = attenuationL * attenuationV;\n\n      let temp = ndoth * ndoth * (r2 - 1.0) + 1.0;\n      let d = r2 / (pi * temp * temp);\n\n      let diffuse = (1.0 - f) / pi * diffuseColor;\n      let specular = max(f * g * d / (4.0 * ndotl * ndotv), vec3<f32>(0.0));\n      return ndotl * (diffuse + specular) * 2.0 + color * 0.1;\n  }\n\n  [[stage(fragment)]]\n  fn main([[location(0)]] vNormal: vec3<f32>,\n          [[location(1)]] worldPos: vec3<f32>,\n          ${n?`[[location(${b+=1})]] uv: vec2<f32>, /* wgsl */`:""}\n          ${r?`[[location(${b+=1})]] uv1: vec2<f32>, /* wgsl */`:""}\n          ${i?`[[location(${b+=1})]] tangent: vec3<f32>,\n                 [[location(${b+=1})]] bitangent: vec3<f32>, /* wgsl */`:""}\n          ${o?`[[location(${b+=1})]] vColor: vec4<f32>, /* wgsl */`:""}) -> [[location(0)]] vec4<f32>\n  {\n      let lightDir = normalize(vec3<f32>(2.0, 4.0, 3.0));\n\n      var color = vec4<f32>(${d(m[0])},\n                            ${d(m[1])},\n                            ${d(m[2])},\n                            ${d(m[3])});\n      ${s?`color = color * linearSample(tex, texSampler, uv${p}); /* wgsl */`:""}\n      ${o?"color = color * vColor;":""}\n\n      ${"MASK"===t.alphaMode?`if (color.a < ${d(t.alphaCutoff,.5)})\n             {\n               discard;\n             } /* wgsl */`:""}\n\n      var metallic: f32 = ${d(l)};\n      var roughness: f32 = ${d(c)};\n      ${a?`let metalRough = textureSample(metalRoughTex, metalRoughSampler, uv${g});\n             metallic = metallic * metalRough.b;\n             roughness = roughness * metalRough.g; /* wgsl */`:""}\n      roughness = clamp(roughness, 0.04, 1.0);\n\n      ${u?`var normal = textureSample(normalTex, normalSampler, uv${y}).rgb;\n             normal = normal * 2.0 - 1.0;\n             normal.x = normal.x * ${d(u.scale)};\n             normal.y = normal.y * ${d(u.scale)};\n             normal = normal.x * tangent + normal.y * bitangent + normal.z * vNormal;\n             normal = normalize(normal); /* wgsl */`:"var normal = normalize(vNormal); /* wgsl */"}\n\n      ${f?`var ao = textureSample(occlusionTex, occlusionSampler, uv${w}).r;\n             ao = 1.0 + ${d(f.strength)} * (ao - 1.0);\n             /* wgsl */`:"let ao = 1.0;"}\n      var emissive = vec3<f32>(${d(v[0])},\n                               ${d(v[1])},\n                               ${d(v[2])});\n      ${h?`emissive = emissive * linearSample(emissiveTex, emissiveSampler, uv${x}).rgb; /* wgsl */`:""}\n\n      let viewDir = normalize(camera.eye - worldPos);\n      ${t.doubleSided?"if (dot(normal, viewDir) < 0.0)\n             {\n               normal = -normal;\n             } /* wgsl */":""}\n\n      var rgb = brdf(color.rgb, metallic, roughness, lightDir, viewDir, normal) * ao + emissive;\n      rgb = pow(rgb, vec3<f32>(1.0 / 2.2));\n      return vec4<f32>(rgb, color.a);\n  }`}class S{constructor(e,t){this.isTransparent=!1,this.vertexCount=e.vertexCount,this.indexFormat=e.indices instanceof Uint16Array?"uint16":"uint32",this.positions=h(e.positions,GPUBufferUsage.VERTEX,t),this.normals=h(e.normals,GPUBufferUsage.VERTEX,t),this.indices=e.indices?h(e.indices,GPUBufferUsage.INDEX,t):null,this.uvs=e.uvs?h(e.uvs,GPUBufferUsage.VERTEX,t):null,this.uv1s=e.uv1s?h(e.uv1s,GPUBufferUsage.VERTEX,t):null,this.tangents=e.tangents?h(e.tangents,GPUBufferUsage.VERTEX,t):null,this.colors=e.colors?h(e.colors,GPUBufferUsage.VERTEX,t):null}draw(e,t){e.setPipeline(this.pipeline),e.setVertexBuffer(0,this.positions),e.setVertexBuffer(1,this.normals);let n=2;this.uvs&&(e.setVertexBuffer(n,this.uvs),n+=1),this.uv1s&&(e.setVertexBuffer(n,this.uv1s),n+=1),this.tangents&&(e.setVertexBuffer(n,this.tangents),n+=1),this.colors&&(e.setVertexBuffer(n,this.colors),n+=1),e.setBindGroup(1,this.uniformBindGroup),this.indices?(e.setIndexBuffer(this.indices,this.indexFormat),e.drawIndexed(this.vertexCount,t)):e.draw(this.vertexCount,t)}destroy(){var e,t,n,r;null===(e=this.indices)||void 0===e||e.destroy(),this.positions.destroy(),this.normals.destroy(),null===(t=this.uvs)||void 0===t||t.destroy(),null===(n=this.uv1s)||void 0===n||n.destroy(),null===(r=this.tangents)||void 0===r||r.destroy()}}const R=r(),U=i(0,1,0);class A{constructor(e,t,n){this.radius=3,this.theta=0,this.phi=0,this.eye=i(0,0,3),this.view=w(),this.yfov=Math.PI/3,this.proj=w(),this.projView=w();const r=e.clientWidth/e.clientHeight;if(n){if(this.view=n.view,"perspective"===n.json.type){const{yfov:e,zfar:t,znear:i}=n.json.perspective;this.yfov=e,T(this.proj,e,r,i,t||1/0)}else{const{ymag:e,zfar:t,znear:i}=n.json.orthographic;this.ymag=e,this.proj[0]=1/(e*r),this.proj[5]=1/e,this.proj[10]=1/(i-t),this.proj[14]=i/(i-t)}M(this.projView,this.proj,this.view)}else{T(this.proj,this.yfov,r,.01,1/0),this.update();let t=!1;e.onmousedown=e=>{e.preventDefault(),t=!0},e.onmouseup=e=>{e.preventDefault(),t=!1},e.onmousemove=e=>{e.preventDefault(),t&&(this.theta-=e.movementX/window.innerWidth*Math.PI*2,this.phi=u(this.phi-e.movementY/window.innerHeight*Math.PI,-Math.PI/2+.1,Math.PI/2-.1),this.update())},e.onwheel=e=>{e.preventDefault(),this.radius=u(this.radius+.002*e.deltaY,.05,1/0),this.update()}}this.projViewBuffer=t.createBuffer({size:64,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.eyeBuffer=t.createBuffer({size:12,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.bindGroup=t.createBindGroup({layout:t.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{}},{binding:1,visibility:GPUShaderStage.FRAGMENT,buffer:{}}]}),entries:[{binding:0,resource:{buffer:this.projViewBuffer}},{binding:1,resource:{buffer:this.eyeBuffer}}]}),window.addEventListener("resize",(()=>{const t=e.clientWidth/e.clientHeight;void 0===this.ymag?this.proj[0]=1/(Math.tan(this.yfov/2)*t):this.proj[0]=1/(this.ymag*t),M(this.projView,this.proj,this.view)}))}update(){var t,n,r,o,s,a;this.eye=i(0,0,this.radius),t=this.eye,n=this.eye,r=R,o=this.phi,a=[],(s=[])[0]=n[0]-r[0],s[1]=n[1]-r[1],s[2]=n[2]-r[2],a[0]=s[0],a[1]=s[1]*Math.cos(o)-s[2]*Math.sin(o),a[2]=s[1]*Math.sin(o)+s[2]*Math.cos(o),t[0]=a[0]+r[0],t[1]=a[1]+r[1],t[2]=a[2]+r[2],function(e,t,n,r){var i=[],o=[];i[0]=t[0]-n[0],i[1]=t[1]-n[1],i[2]=t[2]-n[2],o[0]=i[2]*Math.sin(r)+i[0]*Math.cos(r),o[1]=i[1],o[2]=i[2]*Math.cos(r)-i[0]*Math.sin(r),e[0]=o[0]+n[0],e[1]=o[1]+n[1],e[2]=o[2]+n[2]}(this.eye,this.eye,R,this.theta),function(t,n,r,i){var o,s,a,l,c,u,d,f,h,m,v=n[0],p=n[1],g=n[2],y=i[0],w=i[1],x=i[2],b=r[0],T=r[1],M=r[2];Math.abs(v-b)<e&&Math.abs(p-T)<e&&Math.abs(g-M)<e?function(e){e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1}(t):(d=v-b,f=p-T,h=g-M,o=w*(h*=m=1/Math.hypot(d,f,h))-x*(f*=m),s=x*(d*=m)-y*h,a=y*f-w*d,(m=Math.hypot(o,s,a))?(o*=m=1/m,s*=m,a*=m):(o=0,s=0,a=0),l=f*a-h*s,c=h*o-d*a,u=d*s-f*o,(m=Math.hypot(l,c,u))?(l*=m=1/m,c*=m,u*=m):(l=0,c=0,u=0),t[0]=o,t[1]=l,t[2]=d,t[3]=0,t[4]=s,t[5]=c,t[6]=f,t[7]=0,t[8]=a,t[9]=u,t[10]=h,t[11]=0,t[12]=-(o*v+s*p+a*g),t[13]=-(l*v+c*p+u*g),t[14]=-(d*v+f*p+h*g),t[15]=1)}(this.view,this.eye,R,U),M(this.projView,this.proj,this.view)}bind(e,t){const n=this.projView;e.queue.writeBuffer(this.projViewBuffer,0,n.buffer,n.byteOffset,n.byteLength);const r=this.eye;e.queue.writeBuffer(this.eyeBuffer,0,r.buffer,r.byteOffset,r.byteLength),t.setBindGroup(0,this.bindGroup)}destroy(){this.projViewBuffer.destroy(),this.eyeBuffer.destroy()}}class ${constructor(e,n,r,i,o){this.meshes={},this.textures={},this.cameras=[],this.camera=new A(r,i);const s=(n,r=w())=>{var o;const a=(l=r,(c=new t(16))[0]=l[0],c[1]=l[1],c[2]=l[2],c[3]=l[3],c[4]=l[4],c[5]=l[5],c[6]=l[6],c[7]=l[7],c[8]=l[8],c[9]=l[9],c[10]=l[10],c[11]=l[11],c[12]=l[12],c[13]=l[13],c[14]=l[14],c[15]=l[15],c);var l,c;if(n.matrix)b(a,a,n.matrix);else{if(n.translation&&function(e,t,n){var r,i,o,s,a,l,c,u,d,f,h,m,v=n[0],p=n[1],g=n[2];t===e?(e[12]=t[0]*v+t[4]*p+t[8]*g+t[12],e[13]=t[1]*v+t[5]*p+t[9]*g+t[13],e[14]=t[2]*v+t[6]*p+t[10]*g+t[14],e[15]=t[3]*v+t[7]*p+t[11]*g+t[15]):(r=t[0],i=t[1],o=t[2],s=t[3],a=t[4],l=t[5],c=t[6],u=t[7],d=t[8],f=t[9],h=t[10],m=t[11],e[0]=r,e[1]=i,e[2]=o,e[3]=s,e[4]=a,e[5]=l,e[6]=c,e[7]=u,e[8]=d,e[9]=f,e[10]=h,e[11]=m,e[12]=r*v+a*p+d*g+t[12],e[13]=i*v+l*p+f*g+t[13],e[14]=o*v+c*p+h*g+t[14],e[15]=s*v+u*p+m*g+t[15])}(a,a,n.translation),n.rotation){const e=w();!function(e,t){var n=t[0],r=t[1],i=t[2],o=t[3],s=n+n,a=r+r,l=i+i,c=n*s,u=r*s,d=r*a,f=i*s,h=i*a,m=i*l,v=o*s,p=o*a,g=o*l;e[0]=1-d-m,e[1]=u+g,e[2]=f-p,e[3]=0,e[4]=u-g,e[5]=1-c-m,e[6]=h+v,e[7]=0,e[8]=f+p,e[9]=h-v,e[10]=1-c-d,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1}(e,n.rotation),b(a,a,e)}n.scale&&function(e,t,n){var r=n[0],i=n[1],o=n[2];e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e[4]=t[4]*i,e[5]=t[5]*i,e[6]=t[6]*i,e[7]=t[7]*i,e[8]=t[8]*o,e[9]=t[9]*o,e[10]=t[10]*o,e[11]=t[11]*o,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]}(a,a,n.scale)}if(void 0!==n.mesh){const t=w();x(t,a),function(e,t){if(e===t){var n=t[1],r=t[2],i=t[3],o=t[6],s=t[7],a=t[11];e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=n,e[6]=t[9],e[7]=t[13],e[8]=r,e[9]=o,e[11]=t[14],e[12]=i,e[13]=s,e[14]=a}else e[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15]}(t,t),this.meshes[n.mesh]?(this.meshes[n.mesh].matrices.push(a),this.meshes[n.mesh].matrices.push(t)):this.meshes[n.mesh]={matrices:[a,t],matrixBuffer:void 0,primitives:e.meshes[n.mesh].map((e=>new S(e,i)))}}if(void 0!==n.camera){const t={view:a,json:e.cameras[n.camera]};x(t.view,t.view),this.cameras.push(t)}null===(o=n.children)||void 0===o||o.forEach((t=>s(e.nodes[t],a)))};e.scenes[n].nodes.forEach((t=>{s(e.nodes[t])})),Object.entries(this.meshes).forEach((([t,n])=>{n.matrixBuffer=h(function(e){let t=0;e.forEach((e=>{t+=e.length}));const n=new Float32Array(t);return t=0,e.forEach((e=>{n.set(e,t),t+=e.length})),n}(n.matrices),GPUBufferUsage.UNIFORM,i),n.primitives.forEach(((r,s)=>{const{material:a}=e.meshes[Number(t)][s],{baseColorTexture:l,metallicRoughnessTexture:c}=a.pbrMetallicRoughness,{normalTexture:u,occlusionTexture:d,emissiveTexture:f}=a,h=[l,c,u,d,f];r.isTransparent="BLEND"===a.alphaMode,h.forEach((t=>{if(t&&!this.textures[t.source]){const n=e.images[t.source];this.textures[t.source]=i.createTexture({size:[n.width,n.height,1],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT}),i.queue.copyExternalImageToTexture({source:n},{texture:this.textures[t.source]},[n.width,n.height])}})),r.pipeline=function(e,t,n,r,i){let o=-1;function s(e){return o+=1,{attributes:[{shaderLocation:o,offset:0,format:`float32x${e}`}],arrayStride:4*e}}const a=[s(3),s(3)];null!==r.uvs&&a.push(s(2)),null!==r.uv1s&&a.push(s(2)),null!==r.tangents&&a.push(s(4)),null!==r.colors&&a.push(s(4));const l=[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{}}];return m(n).forEach(((e,t)=>{e&&(l.push({binding:2*t+1,visibility:GPUShaderStage.FRAGMENT,sampler:{}}),l.push({binding:2*t+2,visibility:GPUShaderStage.FRAGMENT,texture:{}}))})),e.createRenderPipeline({layout:e.createPipelineLayout({bindGroupLayouts:[e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{}},{binding:1,visibility:GPUShaderStage.FRAGMENT,buffer:{}}]}),e.createBindGroupLayout({entries:l})]}),vertex:{module:e.createShaderModule({code:E(r,i)}),entryPoint:"main",buffers:a},fragment:{module:e.createShaderModule({code:P(r,n)}),entryPoint:"main",targets:[{format:t,blend:{color:"BLEND"!==n.alphaMode?{operation:"add",srcFactor:"one",dstFactor:"zero"}:{operation:"add",srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{operation:"add",srcFactor:"zero",dstFactor:"one"}}}]},primitive:{topology:"triangle-list",cullMode:n.doubleSided?"none":"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus"}})}(i,o,a,r,n.matrices.length/2);const v=[{binding:0,resource:{buffer:n.matrixBuffer}}];h.forEach(((e,t)=>{if(e){const{addressModeU:n,addressModeV:r,magFilter:o,minFilter:s}=e.sampler;v.push({binding:2*t+1,resource:i.createSampler({addressModeU:n,addressModeV:r,magFilter:o,minFilter:s})}),v.push({binding:2*t+2,resource:this.textures[e.source].createView()})}})),r.uniformBindGroup=i.createBindGroup({layout:r.pipeline.getBindGroupLayout(1),entries:v})}))}))}destroy(){this.camera.destroy(),Object.entries(this.meshes).forEach((([,e])=>{e.matrixBuffer.destroy(),e.primitives.forEach((e=>{e.destroy()}))})),Object.entries(this.textures).forEach((([,e])=>e.destroy()))}}var C=function(e,t,n,r){return new(n||(n=Promise))((function(i,o){function s(e){try{l(r.next(e))}catch(e){o(e)}}function a(e){try{l(r.throw(e))}catch(e){o(e)}}function l(e){var t;e.done?i(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(s,a)}l((r=r.apply(e,t||[])).next())}))};const B=n(466);class V{constructor(e,t,n,r){this.canvas=e,this.device=t,this.context=n,this.contextFormat=r;let i=t.createTexture({size:[e.clientWidth*devicePixelRatio,e.clientHeight*devicePixelRatio],format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT});this.renderPassDesc={colorAttachments:[],depthStencilAttachment:{view:i.createView(),depthLoadValue:1,depthStoreOp:"store",stencilLoadValue:0,stencilStoreOp:"store"}},window.addEventListener("resize",(()=>{const o=[e.clientWidth*devicePixelRatio,e.clientHeight*devicePixelRatio];n.configure({device:t,format:r,size:o}),i.destroy(),i=t.createTexture({size:o,format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT}),this.renderPassDesc.depthStencilAttachment.view=i.createView()})),this.stats=new B,this.stats.showPanel(0),this.stats.dom.style.left="",this.stats.dom.style.right="0px",document.body.appendChild(this.stats.dom)}render(){const e=()=>{this.stats.begin();const t=this.device.createCommandEncoder();this.renderPassDesc.colorAttachments=[{view:this.context.getCurrentTexture().createView(),loadValue:{r:.3,g:.5,b:.7,a:1},storeOp:"store"}];const n=t.beginRenderPass(this.renderPassDesc);this.scene.camera.bind(this.device,n),Object.entries(this.scene.meshes).forEach((([,e])=>{e.primitives.forEach((t=>{t.isTransparent||t.draw(n,e.matrices.length/2)}))})),Object.entries(this.scene.meshes).forEach((([,e])=>{e.primitives.forEach((t=>{t.isTransparent&&t.draw(n,e.matrices.length/2)}))})),n.endPass(),this.device.queue.submit([t.finish()]),this.stats.end(),void 0!==this.requestId&&(this.requestId=requestAnimationFrame(e))};this.requestId=requestAnimationFrame(e)}load(e){var t;return C(this,void 0,void 0,(function*(){this.gltf=yield function(e){return p(this,void 0,void 0,(function*(){if("gltf"===e.split(".").pop()){const t=yield function(e){return new Promise((t=>{const n=new XMLHttpRequest;n.overrideMimeType("application/json"),n.open("GET",e),n.onreadystatechange=()=>{4===n.readyState&&200===n.status&&t(JSON.parse(n.responseText))},n.send(null)}))}(e);return y(t,e)}const t=yield f(e),n=new Uint32Array(t,12,1)[0],r=new Uint8Array(t,20,n);return y(JSON.parse(new TextDecoder("utf-8").decode(r)),e,t,28+n)}))}(e),void 0!==this.requestId&&cancelAnimationFrame(this.requestId),null===(t=this.scene)||void 0===t||t.destroy(),this.scene=new $(this.gltf,this.gltf.defaultScene,this.canvas,this.device,this.contextFormat),this.render()}))}getCameraCount(){return this.scene?this.scene.cameras.length:0}setCamera(e){var t;null===(t=this.scene)||void 0===t||t.camera.destroy(),this.scene&&(this.scene.camera=new A(this.canvas,this.device,void 0!==e?this.scene.cameras[e]:void 0))}}var G=function(e,t,n,r){return new(n||(n=Promise))((function(i,o){function s(e){try{l(r.next(e))}catch(e){o(e)}}function a(e){try{l(r.throw(e))}catch(e){o(e)}}function l(e){var t;e.done?i(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(s,a)}l((r=r.apply(e,t||[])).next())}))};const O=document.getElementById("webgpu-canvas"),F=document.getElementById("model-select"),I=document.getElementById("camera-select"),j=document.createElement("option");j.innerHTML="User Camera",j.value="User Camera";const N=document.getElementById("glb-upload");fetch("https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/model-index.json").then((e=>e.json())).then((e=>{e.forEach((e=>G(void 0,void 0,void 0,(function*(){const t=document.createElement("option");if(t.innerHTML=e.name,t.value=`https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/${e.name}/glTF/${e.name}.gltf`,F.add(t),"DamagedHelmet"===e.name){F.value=t.value;const e=yield function(e){return C(this,void 0,void 0,(function*(){const t=navigator.gpu;if(!t)throw new Error("WebGPU is not supported on this browser.");const n=yield t.requestAdapter(),r=yield n.requestDevice(),i=e.getContext("webgpu"),o=i.getPreferredFormat(n);return i.configure({device:r,format:o,size:[e.clientWidth*devicePixelRatio,e.clientHeight*devicePixelRatio]}),new V(e,r,i,o)}))}(O),n=t=>G(void 0,void 0,void 0,(function*(){yield e.load(t),I.innerHTML="",I.add(j);for(let t=0;t<e.getCameraCount();t+=1){const e=document.createElement("option");e.innerHTML=String(t),e.value=String(t),I.add(e)}}));n(F.value),F.onchange=()=>n(F.value),I.onchange=()=>{e.setCamera("User Camera"!==I.value?Number(I.value):void 0)},N.onchange=()=>{n(URL.createObjectURL(N.files[0]))}}}))))}))})()})();