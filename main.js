(()=>{var e={466:function(e){var t;e.exports=((t=function(){function e(e){return i.appendChild(e.dom),e}function n(e){for(var t=0;t<i.children.length;t++)i.children[t].style.display=t===e?"block":"none";r=e}var r=0,i=document.createElement("div");i.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",i.addEventListener("click",(function(e){e.preventDefault(),n(++r%i.children.length)}),!1);var s=(performance||Date).now(),o=s,a=0,l=e(new t.Panel("FPS","#0ff","#002")),c=e(new t.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var u=e(new t.Panel("MB","#f08","#201"));return n(0),{REVISION:16,dom:i,addPanel:e,showPanel:n,begin:function(){s=(performance||Date).now()},end:function(){a++;var e=(performance||Date).now();if(c.update(e-s,200),e>o+1e3&&(l.update(1e3*a/(e-o),100),o=e,a=0,u)){var t=performance.memory;u.update(t.usedJSHeapSize/1048576,t.jsHeapSizeLimit/1048576)}return e},update:function(){s=this.end()},domElement:i,setMode:n}}).Panel=function(e,t,n){var r=1/0,i=0,s=Math.round,o=s(window.devicePixelRatio||1),a=80*o,l=48*o,c=3*o,u=2*o,h=3*o,f=15*o,d=74*o,m=30*o,v=document.createElement("canvas");v.width=a,v.height=l,v.style.cssText="width:80px;height:48px";var p=v.getContext("2d");return p.font="bold "+9*o+"px Helvetica,Arial,sans-serif",p.textBaseline="top",p.fillStyle=n,p.fillRect(0,0,a,l),p.fillStyle=t,p.fillText(e,c,u),p.fillRect(h,f,d,m),p.fillStyle=n,p.globalAlpha=.9,p.fillRect(h,f,d,m),{dom:v,update:function(l,g){r=Math.min(r,l),i=Math.max(i,l),p.fillStyle=n,p.globalAlpha=1,p.fillRect(0,0,a,f),p.fillStyle=t,p.fillText(s(l)+" "+e+" ("+s(r)+"-"+s(i)+")",c,u),p.drawImage(v,h+o,f,d-o,m,h,f,d-o,m),p.fillRect(h+d-o,f,o,m),p.fillStyle=n,p.globalAlpha=.9,p.fillRect(h+d-o,f,o,s((1-l/g)*m))}}},t)}},t={};function n(r){var i=t[r];if(void 0!==i)return i.exports;var s=t[r]={exports:{}};return e[r].call(s.exports,s,s.exports,n),s.exports}(()=>{"use strict";var e=1e-6,t="undefined"!=typeof Float32Array?Float32Array:Array;function r(){var e=new t(3);return t!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function i(e,n,r){var i=new t(3);return i[0]=e,i[1]=n,i[2]=r,i}function s(e,t,n){return e[0]=Math.min(t[0],n[0]),e[1]=Math.min(t[1],n[1]),e[2]=Math.min(t[2],n[2]),e}function o(e,t,n){return e[0]=Math.max(t[0],n[0]),e[1]=Math.max(t[1],n[1]),e[2]=Math.max(t[2],n[2]),e}function a(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e}function l(e,t){var n=t[0],r=t[1],i=t[2],s=n*n+r*r+i*i;return s>0&&(s=1/Math.sqrt(s)),e[0]=t[0]*s,e[1]=t[1]*s,e[2]=t[2]*s,e}function c(e,t,n){var r=t[0],i=t[1],s=t[2],o=n[0],a=n[1],l=n[2];return e[0]=i*l-s*a,e[1]=s*o-r*l,e[2]=r*a-i*o,e}function u(e,t,n){var r=t[0],i=t[1],s=t[2],o=n[3]*r+n[7]*i+n[11]*s+n[15];return o=o||1,e[0]=(n[0]*r+n[4]*i+n[8]*s+n[12])/o,e[1]=(n[1]*r+n[5]*i+n[9]*s+n[13])/o,e[2]=(n[2]*r+n[6]*i+n[10]*s+n[14])/o,e}Math.random,Math.PI,Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});var h=function(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e};function f(){var e=new t(2);return t!=Float32Array&&(e[0]=0,e[1]=0),e}r();var d=function(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e};function m(e,t,n){return Math.min(Math.max(e,t),n)}function v(e,t=1){const n=void 0!==e?e:t;return Number.isInteger(n)?`${n}.0`:n}function p(e){return new Promise((t=>{const n=new XMLHttpRequest;n.responseType="arraybuffer",n.open("GET",e),n.onreadystatechange=()=>{4===n.readyState&&200===n.status&&t(n.response)},n.send(null)}))}function g(e,t,n){const r=n.createBuffer({size:e.byteLength+3&-4,usage:t,mappedAtCreation:!0});let i;return i=e instanceof Int8Array?new Int8Array(r.getMappedRange()):e instanceof Uint8Array?new Uint8Array(r.getMappedRange()):e instanceof Int16Array?new Int16Array(r.getMappedRange()):e instanceof Uint16Array?new Uint16Array(r.getMappedRange()):e instanceof Uint32Array?new Uint32Array(r.getMappedRange()):new Float32Array(r.getMappedRange()),i.set(e),r.unmap(),r}function x(e){const{baseColorTexture:t,metallicRoughnessTexture:n}=e.pbrMetallicRoughness,{normalTexture:r,occlusionTexture:i,emissiveTexture:s}=e;return[t,n,r,i,s]}f();const y={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16,9728:"nearest",9729:"linear",9984:"linear",9985:"linear",9986:"linear",9987:"linear",33071:"clamp-to-edge",33648:"mirror-repeat",10497:"repeat"};var w=function(e,t,n,r){return new(n||(n=Promise))((function(i,s){function o(e){try{l(r.next(e))}catch(e){s(e)}}function a(e){try{l(r.throw(e))}catch(e){s(e)}}function l(e){var t;e.done?i(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(o,a)}l((r=r.apply(e,t||[])).next())}))};class b{constructor(e,n,s,o=0){function u(e){return{magFilter:y[e.magFilter||9729],minFilter:y[e.minFilter||9729],addressModeU:y[e.wrapS||10497],addressModeV:y[e.wrapT||10497]}}this.scenes=e.scenes,this.defaultScene=e.scene||0,this.nodes=e.nodes,this.cameras=e.cameras||null,this.images=s;const m=e.samplers?e.samplers.map((e=>u(e))):[],v=u({}),p=e.textures?e.textures.map((e=>(e.sampler=void 0!==e.sampler?m[e.sampler]:v,e))):[],g=e.materials?e.materials.map((e=>(e.pbrMetallicRoughness||(e.pbrMetallicRoughness={}),x(e).forEach((e=>{e&&(e.source=p[e.index].source,e.sampler=p[e.index].sampler)})),e))):[],w={pbrMetallicRoughness:{}},b=e.accessors.map((t=>{const r=y[t.type],i=e.bufferViews[t.bufferView],s=(i.byteOffset||0)+(t.byteOffset||0);let a=i.byteStride/4;a=a>r?a:r;const l=function(e,t,n,r){switch(e){case 5120:return new Int8Array(t,n,r);case 5121:return new Uint8Array(t,n,r);case 5122:return new Int16Array(t,n,r);case 5123:return new Uint16Array(t,n,r);case 5125:return new Uint32Array(t,n,r);case 5126:return new Float32Array(t,n,r);default:throw new Error("invalid component type")}}(t.componentType,n[i.buffer],0===i.buffer?s+o:s,(t.count-1)*a+r);if(a>r){const e=new(0,l.constructor)(t.count*r);for(let t=0,n=0;t<e.length;t+=r,n+=a)for(let i=0;i<r;i+=1)e[t+i]=l[n+i];return e}return l}));this.meshes=e.meshes.map((n=>n.primitives.map((n=>{const s=void 0!==n.material?g[n.material]:w;let o,u=null;void 0!==n.indices?(u=function(e){if(e instanceof Uint16Array||e instanceof Uint32Array)return e;let t;return t=e instanceof Float32Array?new Uint32Array(e.length):new Uint16Array(e.length),e.forEach(((e,n)=>{t[n]=e})),t}(b[n.indices]),o=e.accessors[n.indices].count):o=e.accessors[n.attributes.POSITION].count;const m=b[n.attributes.POSITION],{max:v,min:p}=e.accessors[n.attributes.POSITION],x={max:v,min:p};let y;y=void 0!==n.attributes.NORMAL?b[n.attributes.NORMAL]:function(e,t){const n=new Float32Array(t.length),s=e?e.length:t.length;for(let o=0;o<s;o+=3){const s=[];for(let t=0;t<3;t+=1)e?s.push(e[o+t]):s.push(o+t);const a=s.map((e=>{const n=3*e;return i(t[n],t[n+1],t[n+2])})),u=r();h(u,a[1],a[0]);const f=r();h(f,a[2],a[0]);const d=r();c(d,l(u,u),l(u,f));for(let e=0;e<3;e+=1){const t=3*(o+e);for(let e=0;e<3;e+=1)n[t+e]+=d[e]}}return n}(u,m);let T=null;void 0!==n.attributes.TEXCOORD_0&&(T=b[n.attributes.TEXCOORD_0]);let M=null;void 0!==n.attributes.TEXCOORD_1&&(M=b[n.attributes.TEXCOORD_1]);let E=null;void 0!==n.attributes.TANGENT&&void 0!==n.attributes.NORMAL?E=b[n.attributes.TANGENT]:s.normalTexture&&(E=function(e,n,s,o){const c=new Float32Array(s.length/3*4),u=e?e.length:n.length;for(let s=0;s<u;s+=3){const u=[];for(let t=0;t<3;t+=1)e?u.push(e[s+t]):u.push(s+t);const m=u.map((e=>{const t=3*e;return i(n[t],n[t+1],n[t+2])})),v=u.map((e=>{const n=2*e;return r=o[n],i=o[n+1],(s=new t(2))[0]=r,s[1]=i,s;var r,i,s})),p=r();h(p,m[1],m[0]);const g=r();h(g,m[2],m[0]);const x=f();d(x,v[1],v[0]);const y=f();d(y,v[2],v[0]);const w=y[1]*x[0]-x[1]*y[0]>=0?1:-1,b=r();h(b,a(p,p,y[1]),a(g,g,x[1])),l(b,b);for(let e=0;e<3;e+=1){const t=4*(s+e);for(let e=0;e<3;e+=1)c[t+e]+=b[e];c[t+3]=w}}return c}(u,m,y,T));let P=null;return void 0!==n.attributes.COLOR_0&&(P=b[n.attributes.COLOR_0]),{vertexCount:o,indices:u,positions:m,normals:y,uvs:T,uv1s:M,tangents:E,colors:P,material:s,boundingBox:x}}))))}}function T(e,t,n,r=0){return w(this,void 0,void 0,(function*(){const i=t.substring(0,t.lastIndexOf("/")),s=[];let o=Promise.resolve();e.images&&(o=Promise.all(e.images.map(((e,t)=>w(this,void 0,void 0,(function*(){if(e.uri){const n=new Image;n.crossOrigin="Anonymous",n.src=`${i}/${e.uri}`,yield n.decode(),s[t]=yield createImageBitmap(n,{colorSpaceConversion:"none"})}}))))));const a=[];yield Promise.all(e.buffers.map(((e,t)=>{if(!e.uri){if(0!==t)throw new Error("buffer uri undefined");return a[t]=n,Promise.resolve()}return p(`${i}/${e.uri}`).then((e=>{a[t]=e}))})));let l=Promise.resolve();return e.images&&(l=Promise.all(e.images.map(((t,n)=>w(this,void 0,void 0,(function*(){if(void 0!==t.bufferView){const{buffer:i,byteOffset:o,byteLength:l}=e.bufferViews[t.bufferView],c=new Uint8Array(a[i],0===i?o+r:o,l);let u;u=t.mimeType?t.mimeType:255===c[0]?"image/jpeg":"image/png";const h=new Blob([c],{type:u});s[n]=yield createImageBitmap(h,{colorSpaceConversion:"none"})}})))))),yield Promise.all([o,l]),new b(e,a,s,r)}))}function M(){var e=new t(16);return t!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function E(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=t[4],a=t[5],l=t[6],c=t[7],u=t[8],h=t[9],f=t[10],d=t[11],m=t[12],v=t[13],p=t[14],g=t[15],x=n*a-r*o,y=n*l-i*o,w=n*c-s*o,b=r*l-i*a,T=r*c-s*a,M=i*c-s*l,E=u*v-h*m,P=u*p-f*m,A=u*g-d*m,S=h*p-f*v,R=h*g-d*v,U=f*g-d*p,$=x*U-y*R+w*S+b*A-T*P+M*E;return $?($=1/$,e[0]=(a*U-l*R+c*S)*$,e[1]=(i*R-r*U-s*S)*$,e[2]=(v*M-p*T+g*b)*$,e[3]=(f*T-h*M-d*b)*$,e[4]=(l*A-o*U-c*P)*$,e[5]=(n*U-i*A+s*P)*$,e[6]=(p*w-m*M-g*y)*$,e[7]=(u*M-f*w+d*y)*$,e[8]=(o*R-a*A+c*E)*$,e[9]=(r*A-n*R-s*E)*$,e[10]=(m*T-v*w+g*x)*$,e[11]=(h*w-u*T-d*x)*$,e[12]=(a*P-o*S-l*E)*$,e[13]=(n*S-r*P+i*E)*$,e[14]=(v*y-m*b-p*x)*$,e[15]=(u*b-h*y+f*x)*$,e):null}function P(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],a=t[4],l=t[5],c=t[6],u=t[7],h=t[8],f=t[9],d=t[10],m=t[11],v=t[12],p=t[13],g=t[14],x=t[15],y=n[0],w=n[1],b=n[2],T=n[3];return e[0]=y*r+w*a+b*h+T*v,e[1]=y*i+w*l+b*f+T*p,e[2]=y*s+w*c+b*d+T*g,e[3]=y*o+w*u+b*m+T*x,y=n[4],w=n[5],b=n[6],T=n[7],e[4]=y*r+w*a+b*h+T*v,e[5]=y*i+w*l+b*f+T*p,e[6]=y*s+w*c+b*d+T*g,e[7]=y*o+w*u+b*m+T*x,y=n[8],w=n[9],b=n[10],T=n[11],e[8]=y*r+w*a+b*h+T*v,e[9]=y*i+w*l+b*f+T*p,e[10]=y*s+w*c+b*d+T*g,e[11]=y*o+w*u+b*m+T*x,y=n[12],w=n[13],b=n[14],T=n[15],e[12]=y*r+w*a+b*h+T*v,e[13]=y*i+w*l+b*f+T*p,e[14]=y*s+w*c+b*d+T*g,e[15]=y*o+w*u+b*m+T*x,e}function A(e,t){var n=t[0],r=t[1],i=t[2],s=t[4],o=t[5],a=t[6],l=t[8],c=t[9],u=t[10];return e[0]=Math.hypot(n,r,i),e[1]=Math.hypot(s,o,a),e[2]=Math.hypot(l,c,u),e}var S=function(e,t,n,r,i){var s,o=1/Math.tan(t/2);return e[0]=o/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=o,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=i&&i!==1/0?(s=1/(r-i),e[10]=(i+r)*s,e[14]=2*i*r*s):(e[10]=-1,e[14]=-2*r),e},R=P;function U(e,t){const n=null!==e.uvs,r=null!==e.uv1s,i=null!==e.tangents,s=null!==e.colors;let o=1,a=1;return`\n\n  [[block]] struct Camera\n  {\n      projView: mat4x4<f32>;\n  };\n  [[group(0), binding(0)]] var<uniform> camera: Camera;\n\n  struct Model {\n      matrix: mat4x4<f32>;\n      invTr: mat4x4<f32>;\n  };\n  [[block]] struct Models\n  {\n      model: [[stride(128)]] array<Model, ${t}>;\n  };\n  [[group(1), binding(0)]] var<uniform> models: Models;\n\n  struct VertexOutput\n  {\n      [[builtin(position)]] position: vec4<f32>;\n      [[location(0)]] normal: vec3<f32>;\n      [[location(1)]] worldPos: vec3<f32>;\n      ${n?`[[location(${a+=1})]] uv: vec2<f32>; /* wgsl */`:""}\n      ${r?`[[location(${a+=1})]] uv1: vec2<f32>; /* wgsl */`:""}\n      ${i?`[[location(${a+=1})]] tangent: vec3<f32>;\n             [[location(${a+=1})]] bitangent: vec3<f32>; /* wgsl */`:""}\n      ${s?`[[location(${a+=1})]] color: vec4<f32>; /* wgsl */`:""}\n  };\n\n  [[stage(vertex)]]\n  fn main([[builtin(instance_index)]] instanceIndex : u32,\n          [[location(0)]] pos: vec3<f32>,\n          [[location(1)]] normal: vec3<f32>,\n          ${n?`[[location(${o+=1})]] uv: vec2<f32>, /* wgsl */`:""}\n          ${r?`[[location(${o+=1})]] uv1: vec2<f32>, /* wgsl */`:""}\n          ${i?`[[location(${o+=1})]] tangent: vec4<f32>, /* wgsl */`:""}\n          ${s?`[[location(${o+=1})]] color: vec4<f32>, /* wgsl */`:""}) -> VertexOutput\n  {\n      let model = models.model[instanceIndex];\n      var v: VertexOutput;\n      v.position = camera.projView * model.matrix * vec4<f32>(pos, 1.0);\n      v.normal = normalize((model.invTr * vec4<f32>(normal, 0.0)).xyz);\n      v.worldPos = (model.matrix * vec4<f32>(pos, 1.0)).xyz;\n      ${n?"v.uv = uv;":""}\n      ${r?"v.uv1 = uv1;":""}\n      ${i?"v.tangent = normalize((model.matrix * vec4<f32>(tangent.xyz, 0.0)).xyz);\n             v.bitangent = cross(v.normal, v.tangent) * tangent.w; /* wgsl */":""}\n      ${s?"v.color = color;":""}\n      return v;\n  }`}function $(e,t){const n=null!==e.uvs,r=null!==e.uv1s,i=null!==e.tangents,s=null!==e.colors,{baseColorTexture:o,metallicRoughnessTexture:a,metallicFactor:l,roughnessFactor:c}=t.pbrMetallicRoughness,{normalTexture:u,occlusionTexture:h,emissiveTexture:f}=t;let{baseColorFactor:d}=t.pbrMetallicRoughness;d=d||[1,1,1,1];let{emissiveFactor:m}=t;m=m||[0,0,0];const p=(null==o?void 0:o.texCoord)||"",g=(null==a?void 0:a.texCoord)||"",x=(null==u?void 0:u.texCoord)||"",y=(null==h?void 0:h.texCoord)||"",w=(null==f?void 0:f.texCoord)||"";let b=1;return`\n\n  [[block]] struct Camera\n  {\n      eye: vec3<f32>;\n  };\n  [[group(0), binding(1)]] var<uniform> camera: Camera;\n\n  ${o?"[[group(1), binding(1)]] var texSampler: sampler;\n         [[group(1), binding(2)]] var tex: texture_2d<f32>; /* wgsl */":""}\n  ${a?"[[group(1), binding(3)]] var metalRoughSampler: sampler;\n         [[group(1), binding(4)]] var metalRoughTex: texture_2d<f32>; /* wgsl */":""}\n  ${u?"[[group(1), binding(5)]] var normalSampler: sampler;\n         [[group(1), binding(6)]] var normalTex: texture_2d<f32>; /* wgsl */":""}\n  ${h?"[[group(1), binding(7)]] var occlusionSampler: sampler;\n         [[group(1), binding(8)]] var occlusionTex: texture_2d<f32>; /* wgsl */":""}\n  ${f?"[[group(1), binding(9)]] var emissiveSampler: sampler;\n         [[group(1), binding(10)]] var emissiveTex: texture_2d<f32>; /* wgsl */":""}\n\n  fn linearSample(texture: texture_2d<f32>, texSampler: sampler, uv: vec2<f32>) -> vec4<f32>\n  {\n    let color = textureSample(texture, texSampler, uv);\n    return vec4<f32>(pow(color.rgb, vec3<f32>(2.2)), color.a);\n  }\n\n  let pi: f32 = 3.141592653589793;\n\n  fn blinnPhong(color: vec3<f32>,\n           l: vec3<f32>,\n           v: vec3<f32>,\n           n: vec3<f32>) -> vec3<f32>\n  {\n      let specExp = 64.0;\n      let intensity = 0.5;\n      let ambient = 0.5;\n\n      let diffuse = max(dot(n, l), 0.0);\n      let specular = pow(max(dot(n, normalize(l + v)), 0.0), specExp);\n\n      return color * ((diffuse + specular) * intensity + ambient);\n  }\n\n  fn brdf(color: vec3<f32>,\n          metallic: f32,\n          roughness: f32,\n          l: vec3<f32>,\n          v: vec3<f32>,\n          n: vec3<f32>) -> vec3<f32>\n  {\n      let h = normalize(l + v);\n      let ndotl = clamp(dot(n, l), 0.0, 1.0);\n      let ndotv = abs(dot(n, v));\n      let ndoth = clamp(dot(n, h), 0.0, 1.0);\n      let vdoth = clamp(dot(v, h), 0.0, 1.0);\n\n      let f0 = vec3<f32>(0.04);\n      let diffuseColor = color * (1.0 - f0) * (1.0 - metallic);\n      let specularColor = mix(f0, color, metallic);\n\n      let reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n      let reflectance0 = specularColor;\n      let reflectance9 = vec3<f32>(clamp(reflectance * 25.0, 0.0, 1.0));\n      let f = reflectance0 + (reflectance9 - reflectance0) * pow(1.0 - vdoth, 5.0);\n\n      let r2 = roughness * roughness;\n      let r4 = r2 * r2;\n      let attenuationL = 2.0 * ndotl / (ndotl + sqrt(r4 + (1.0 - r4) * ndotl * ndotl));\n      let attenuationV = 2.0 * ndotv / (ndotv + sqrt(r4 + (1.0 - r4) * ndotv * ndotv));\n      let g = attenuationL * attenuationV;\n\n      let temp = ndoth * ndoth * (r2 - 1.0) + 1.0;\n      let d = r2 / (pi * temp * temp);\n\n      let diffuse = (1.0 - f) / pi * diffuseColor;\n      let specular = max(f * g * d / (4.0 * ndotl * ndotv), vec3<f32>(0.0));\n      return ndotl * (diffuse + specular) * 2.0 + color * 0.1;\n  }\n\n  [[stage(fragment)]]\n  fn main([[location(0)]] vNormal: vec3<f32>,\n          [[location(1)]] worldPos: vec3<f32>,\n          ${n?`[[location(${b+=1})]] uv: vec2<f32>, /* wgsl */`:""}\n          ${r?`[[location(${b+=1})]] uv1: vec2<f32>, /* wgsl */`:""}\n          ${i?`[[location(${b+=1})]] tangent: vec3<f32>,\n                 [[location(${b+=1})]] bitangent: vec3<f32>, /* wgsl */`:""}\n          ${s?`[[location(${b+=1})]] vColor: vec4<f32>, /* wgsl */`:""}) -> [[location(0)]] vec4<f32>\n  {\n      let lightDir = normalize(vec3<f32>(2.0, 4.0, 3.0));\n\n      var color = vec4<f32>(${v(d[0])},\n                            ${v(d[1])},\n                            ${v(d[2])},\n                            ${v(d[3])});\n      ${o?`color = color * linearSample(tex, texSampler, uv${p}); /* wgsl */`:""}\n      ${s?"color = color * vColor;":""}\n\n      ${"MASK"===t.alphaMode?`if (color.a < ${v(t.alphaCutoff,.5)})\n             {\n               discard;\n             } /* wgsl */`:""}\n\n      var metallic: f32 = ${v(l)};\n      var roughness: f32 = ${v(c)};\n      ${a?`let metalRough = textureSample(metalRoughTex, metalRoughSampler, uv${g});\n             metallic = metallic * metalRough.b;\n             roughness = roughness * metalRough.g; /* wgsl */`:""}\n      roughness = clamp(roughness, 0.04, 1.0);\n\n      ${u?`var normal = textureSample(normalTex, normalSampler, uv${x}).rgb;\n             normal = normal * 2.0 - 1.0;\n             normal.x = normal.x * ${v(u.scale)};\n             normal.y = normal.y * ${v(u.scale)};\n             normal = normal.x * tangent + normal.y * bitangent + normal.z * vNormal;\n             normal = normalize(normal); /* wgsl */`:"var normal = normalize(vNormal); /* wgsl */"}\n\n      ${h?`var ao = textureSample(occlusionTex, occlusionSampler, uv${y}).r;\n             ao = 1.0 + ${v(h.strength)} * (ao - 1.0);\n             /* wgsl */`:"let ao = 1.0;"}\n      var emissive = vec3<f32>(${v(m[0])},\n                               ${v(m[1])},\n                               ${v(m[2])});\n      ${f?`emissive = emissive * linearSample(emissiveTex, emissiveSampler, uv${w}).rgb; /* wgsl */`:""}\n\n      let viewDir = normalize(camera.eye - worldPos);\n      ${t.doubleSided?"if (dot(normal, viewDir) < 0.0)\n             {\n               normal = -normal;\n             } /* wgsl */":""}\n\n      var rgb = brdf(color.rgb, metallic, roughness, lightDir, viewDir, normal) * ao + emissive;\n      rgb = pow(rgb, vec3<f32>(1.0 / 2.2));\n      return vec4<f32>(rgb, color.a);\n  }`}class B{constructor(e,t){this.isTransparent=!1,this.vertexCount=e.vertexCount,this.indexFormat=e.indices instanceof Uint16Array?"uint16":"uint32",this.positions=g(e.positions,GPUBufferUsage.VERTEX,t),this.normals=g(e.normals,GPUBufferUsage.VERTEX,t),this.indices=e.indices?g(e.indices,GPUBufferUsage.INDEX,t):null,this.uvs=e.uvs?g(e.uvs,GPUBufferUsage.VERTEX,t):null,this.uv1s=e.uv1s?g(e.uv1s,GPUBufferUsage.VERTEX,t):null,this.tangents=e.tangents?g(e.tangents,GPUBufferUsage.VERTEX,t):null,this.colors=e.colors?g(e.colors,GPUBufferUsage.VERTEX,t):null}draw(e,t){e.setPipeline(this.pipeline),e.setVertexBuffer(0,this.positions),e.setVertexBuffer(1,this.normals);let n=2;this.uvs&&(e.setVertexBuffer(n,this.uvs),n+=1),this.uv1s&&(e.setVertexBuffer(n,this.uv1s),n+=1),this.tangents&&(e.setVertexBuffer(n,this.tangents),n+=1),this.colors&&(e.setVertexBuffer(n,this.colors),n+=1),e.setBindGroup(1,this.uniformBindGroup),this.indices?(e.setIndexBuffer(this.indices,this.indexFormat),e.drawIndexed(this.vertexCount,t)):e.draw(this.vertexCount,t)}destroy(){var e,t,n,r;null===(e=this.indices)||void 0===e||e.destroy(),this.positions.destroy(),this.normals.destroy(),null===(t=this.uvs)||void 0===t||t.destroy(),null===(n=this.uv1s)||void 0===n||n.destroy(),null===(r=this.tangents)||void 0===r||r.destroy()}}const C=r(),F=i(0,1,0);class V{constructor(e,t,n,i){this.eye=r(),this.view=M(),this.proj=M(),this.projView=M();const s=e.clientWidth/e.clientHeight;if(i){if(this.eye=i.eye,this.view=i.view,"perspective"===i.json.type){const{yfov:e,zfar:t,znear:n}=i.json.perspective;this.yfov=e,S(this.proj,e,s,n,t||1/0)}else{const{ymag:e,zfar:t,znear:n}=i.json.orthographic;this.ymag=e,this.proj[0]=1/(e*s),this.proj[5]=1/e,this.proj[10]=1/(n-t),this.proj[14]=n/(n-t)}R(this.projView,this.proj,this.view)}else{this.center=r(),a(this.center,(o=this.center,l=n.max,c=n.min,o[0]=l[0]+c[0],o[1]=l[1]+c[1],o[2]=l[2]+c[2],o),.5);const t=function(e){var t=e[0],n=e[1],r=e[2];return Math.hypot(t,n,r)}(h(C,n.max,n.min));this.radius=t,this.theta=0,this.phi=0,this.yfov=Math.PI/3,S(this.proj,this.yfov,s,t/100,1/0),this.update();let i=!1;e.onmousedown=e=>{e.preventDefault(),i=!0},e.onmouseup=e=>{e.preventDefault(),i=!1},e.onmousemove=e=>{e.preventDefault(),i&&(this.theta-=e.movementX/window.innerWidth*Math.PI*2,this.phi=m(this.phi-e.movementY/window.innerHeight*Math.PI,-Math.PI/2+.1,Math.PI/2-.1),this.update())},e.onwheel=e=>{e.preventDefault(),this.radius=m(this.radius+.001*e.deltaY*t,t/16,1/0),this.update()}}var o,l,c;this.projViewBuffer=t.createBuffer({size:64,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.eyeBuffer=t.createBuffer({size:12,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.bindGroup=t.createBindGroup({layout:t.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{}},{binding:1,visibility:GPUShaderStage.FRAGMENT,buffer:{}}]}),entries:[{binding:0,resource:{buffer:this.projViewBuffer}},{binding:1,resource:{buffer:this.eyeBuffer}}]}),window.addEventListener("resize",(()=>{const t=e.clientWidth/e.clientHeight;void 0===this.ymag?this.proj[0]=1/(Math.tan(this.yfov/2)*t):this.proj[0]=1/(this.ymag*t),R(this.projView,this.proj,this.view)}))}update(){var t,n,r,s,o,a;this.eye=i(this.center[0],this.center[1],this.center[2]+this.radius),t=this.eye,n=this.eye,r=this.center,s=this.phi,a=[],(o=[])[0]=n[0]-r[0],o[1]=n[1]-r[1],o[2]=n[2]-r[2],a[0]=o[0],a[1]=o[1]*Math.cos(s)-o[2]*Math.sin(s),a[2]=o[1]*Math.sin(s)+o[2]*Math.cos(s),t[0]=a[0]+r[0],t[1]=a[1]+r[1],t[2]=a[2]+r[2],function(e,t,n,r){var i=[],s=[];i[0]=t[0]-n[0],i[1]=t[1]-n[1],i[2]=t[2]-n[2],s[0]=i[2]*Math.sin(r)+i[0]*Math.cos(r),s[1]=i[1],s[2]=i[2]*Math.cos(r)-i[0]*Math.sin(r),e[0]=s[0]+n[0],e[1]=s[1]+n[1],e[2]=s[2]+n[2]}(this.eye,this.eye,this.center,this.theta),function(t,n,r,i){var s,o,a,l,c,u,h,f,d,m,v=n[0],p=n[1],g=n[2],x=i[0],y=i[1],w=i[2],b=r[0],T=r[1],M=r[2];Math.abs(v-b)<e&&Math.abs(p-T)<e&&Math.abs(g-M)<e?function(e){e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1}(t):(h=v-b,f=p-T,d=g-M,s=y*(d*=m=1/Math.hypot(h,f,d))-w*(f*=m),o=w*(h*=m)-x*d,a=x*f-y*h,(m=Math.hypot(s,o,a))?(s*=m=1/m,o*=m,a*=m):(s=0,o=0,a=0),l=f*a-d*o,c=d*s-h*a,u=h*o-f*s,(m=Math.hypot(l,c,u))?(l*=m=1/m,c*=m,u*=m):(l=0,c=0,u=0),t[0]=s,t[1]=l,t[2]=h,t[3]=0,t[4]=o,t[5]=c,t[6]=f,t[7]=0,t[8]=a,t[9]=u,t[10]=d,t[11]=0,t[12]=-(s*v+o*p+a*g),t[13]=-(l*v+c*p+u*g),t[14]=-(h*v+f*p+d*g),t[15]=1)}(this.view,this.eye,this.center,F),R(this.projView,this.proj,this.view)}bind(e,t){const n=this.projView;e.queue.writeBuffer(this.projViewBuffer,0,n.buffer,n.byteOffset,n.byteLength);const r=this.eye;e.queue.writeBuffer(this.eyeBuffer,0,r.buffer,r.byteOffset,r.byteLength),t.setBindGroup(0,this.bindGroup)}destroy(){this.projViewBuffer.destroy(),this.eyeBuffer.destroy()}}function G(){var e=new t(4);return t!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e[3]=1,e}!function(){var e;e=new t(4),t!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0,e[3]=0)}();var O;r(),i(1,0,0),i(0,1,0),G(),G(),O=new t(9),t!=Float32Array&&(O[1]=0,O[2]=0,O[3]=0,O[5]=0,O[6]=0,O[7]=0),O[0]=1,O[4]=1,O[8]=1;class I{constructor(e,n,s){this.translation=r(),this.rotation=G(),this.scale=i(1,1,1),this.globalTransform=M(),this.children=[],this.parent=s;const o=e[n];o&&(o.matrix&&(function(e,t){e[0]=t[12],e[1]=t[13],e[2]=t[14]}(this.translation,o.matrix),function(e,n){var r=new t(3);A(r,n);var i=1/r[0],s=1/r[1],o=1/r[2],a=n[0]*i,l=n[1]*s,c=n[2]*o,u=n[4]*i,h=n[5]*s,f=n[6]*o,d=n[8]*i,m=n[9]*s,v=n[10]*o,p=a+h+v,g=0;p>0?(g=2*Math.sqrt(p+1),e[3]=.25*g,e[0]=(f-m)/g,e[1]=(d-c)/g,e[2]=(l-u)/g):a>h&&a>v?(g=2*Math.sqrt(1+a-h-v),e[3]=(f-m)/g,e[0]=.25*g,e[1]=(l+u)/g,e[2]=(d+c)/g):h>v?(g=2*Math.sqrt(1+h-a-v),e[3]=(d-c)/g,e[0]=(l+u)/g,e[1]=.25*g,e[2]=(f+m)/g):(g=2*Math.sqrt(1+v-a-h),e[3]=(l-u)/g,e[0]=(d+c)/g,e[1]=(f+m)/g,e[2]=.25*g)}(this.rotation,o.matrix),A(this.scale,o.matrix)),o.translation&&(this.translation=o.translation),o.rotation&&(this.rotation=o.rotation),o.scale&&(this.scale=o.scale)),function(e,t,n,r){var i=t[0],s=t[1],o=t[2],a=t[3],l=i+i,c=s+s,u=o+o,h=i*l,f=i*c,d=i*u,m=s*c,v=s*u,p=o*u,g=a*l,x=a*c,y=a*u,w=r[0],b=r[1],T=r[2];e[0]=(1-(m+p))*w,e[1]=(f+y)*w,e[2]=(d-x)*w,e[3]=0,e[4]=(f-y)*b,e[5]=(1-(h+p))*b,e[6]=(v+g)*b,e[7]=0,e[8]=(d+x)*T,e[9]=(v-g)*T,e[10]=(1-(h+m))*T,e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1}(this.globalTransform,this.rotation,this.translation,this.scale),s&&R(this.globalTransform,s.globalTransform,this.globalTransform),o&&(void 0!==o.mesh&&(this.mesh=o.mesh),o.children&&(this.children=o.children.map((t=>new I(e,t,this)))))}getAABB(e){const t={max:i(-1/0,-1/0,-1/0),min:i(1/0,1/0,1/0)};if(this.children.forEach((n=>{const r=n.getAABB(e);o(t.max,t.max,r.max),s(t.min,t.min,r.min)})),void 0!==this.mesh){const n={max:i(-1/0,-1/0,-1/0),min:i(1/0,1/0,1/0)};e[this.mesh].forEach((e=>{o(n.max,n.max,e.boundingBox.max),s(n.min,n.min,e.boundingBox.min)}));for(let e=0;e<8;e+=1){const r=i(e%8<4?n.min[0]:n.max[0],e%4<2?n.min[1]:n.max[1],e%2<1?n.min[2]:n.max[2]);u(r,r,this.globalTransform),o(t.max,t.max,r),s(t.min,t.min,r)}}return t}}class j{constructor(e,n,i,s,o){this.meshes={},this.textures={},this.cameras=[];const a=new I(e.nodes,-1,null);a.children=e.scenes[n].nodes.map((t=>new I(e.nodes,t,a))),this.aabb=a.getAABB(e.meshes),this.camera=new V(i,s,this.aabb);const l=(n,i=M())=>{var o;const a=function(e){var n=new t(16);return n[0]=e[0],n[1]=e[1],n[2]=e[2],n[3]=e[3],n[4]=e[4],n[5]=e[5],n[6]=e[6],n[7]=e[7],n[8]=e[8],n[9]=e[9],n[10]=e[10],n[11]=e[11],n[12]=e[12],n[13]=e[13],n[14]=e[14],n[15]=e[15],n}(i);if(n.matrix)P(a,a,n.matrix);else{if(n.translation&&function(e,t,n){var r,i,s,o,a,l,c,u,h,f,d,m,v=n[0],p=n[1],g=n[2];t===e?(e[12]=t[0]*v+t[4]*p+t[8]*g+t[12],e[13]=t[1]*v+t[5]*p+t[9]*g+t[13],e[14]=t[2]*v+t[6]*p+t[10]*g+t[14],e[15]=t[3]*v+t[7]*p+t[11]*g+t[15]):(r=t[0],i=t[1],s=t[2],o=t[3],a=t[4],l=t[5],c=t[6],u=t[7],h=t[8],f=t[9],d=t[10],m=t[11],e[0]=r,e[1]=i,e[2]=s,e[3]=o,e[4]=a,e[5]=l,e[6]=c,e[7]=u,e[8]=h,e[9]=f,e[10]=d,e[11]=m,e[12]=r*v+a*p+h*g+t[12],e[13]=i*v+l*p+f*g+t[13],e[14]=s*v+c*p+d*g+t[14],e[15]=o*v+u*p+m*g+t[15])}(a,a,n.translation),n.rotation){const e=M();!function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=n+n,a=r+r,l=i+i,c=n*o,u=r*o,h=r*a,f=i*o,d=i*a,m=i*l,v=s*o,p=s*a,g=s*l;e[0]=1-h-m,e[1]=u+g,e[2]=f-p,e[3]=0,e[4]=u-g,e[5]=1-c-m,e[6]=d+v,e[7]=0,e[8]=f+p,e[9]=d-v,e[10]=1-c-h,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1}(e,n.rotation),P(a,a,e)}n.scale&&function(e,t,n){var r=n[0],i=n[1],s=n[2];e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e[4]=t[4]*i,e[5]=t[5]*i,e[6]=t[6]*i,e[7]=t[7]*i,e[8]=t[8]*s,e[9]=t[9]*s,e[10]=t[10]*s,e[11]=t[11]*s,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]}(a,a,n.scale)}if(void 0!==n.mesh){const t=M();E(t,a),function(e,t){if(e===t){var n=t[1],r=t[2],i=t[3],s=t[6],o=t[7],a=t[11];e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=n,e[6]=t[9],e[7]=t[13],e[8]=r,e[9]=s,e[11]=t[14],e[12]=i,e[13]=o,e[14]=a}else e[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15]}(t,t),this.meshes[n.mesh]?(this.meshes[n.mesh].matrices.push(a),this.meshes[n.mesh].matrices.push(t)):this.meshes[n.mesh]={matrices:[a,t],matrixBuffer:void 0,primitives:e.meshes[n.mesh].map((e=>new B(e,s)))}}if(void 0!==n.camera){const t={eye:r(),view:a,json:e.cameras[n.camera]};u(t.eye,t.eye,a),E(t.view,t.view),this.cameras.push(t)}null===(o=n.children)||void 0===o||o.forEach((t=>l(e.nodes[t],a)))};e.scenes[n].nodes.forEach((t=>{l(e.nodes[t])})),Object.entries(this.meshes).forEach((([t,n])=>{n.matrixBuffer=g(function(e){let t=0;e.forEach((e=>{t+=e.length}));const n=new Float32Array(t);return t=0,e.forEach((e=>{n.set(e,t),t+=e.length})),n}(n.matrices),GPUBufferUsage.UNIFORM,s),n.primitives.forEach(((r,i)=>{const{material:a}=e.meshes[Number(t)][i],{baseColorTexture:l,metallicRoughnessTexture:c}=a.pbrMetallicRoughness,{normalTexture:u,occlusionTexture:h,emissiveTexture:f}=a,d=[l,c,u,h,f];r.isTransparent="BLEND"===a.alphaMode,d.forEach((t=>{if(t&&!this.textures[t.source]){const n=e.images[t.source];this.textures[t.source]=s.createTexture({size:[n.width,n.height,1],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT}),s.queue.copyExternalImageToTexture({source:n},{texture:this.textures[t.source]},[n.width,n.height])}})),r.pipeline=function(e,t,n,r,i){let s=-1;function o(e){return s+=1,{attributes:[{shaderLocation:s,offset:0,format:`float32x${e}`}],arrayStride:4*e}}const a=[o(3),o(3)];null!==r.uvs&&a.push(o(2)),null!==r.uv1s&&a.push(o(2)),null!==r.tangents&&a.push(o(4)),null!==r.colors&&a.push(o(4));const l=[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{}}];return x(n).forEach(((e,t)=>{e&&(l.push({binding:2*t+1,visibility:GPUShaderStage.FRAGMENT,sampler:{}}),l.push({binding:2*t+2,visibility:GPUShaderStage.FRAGMENT,texture:{}}))})),e.createRenderPipeline({layout:e.createPipelineLayout({bindGroupLayouts:[e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{}},{binding:1,visibility:GPUShaderStage.FRAGMENT,buffer:{}}]}),e.createBindGroupLayout({entries:l})]}),vertex:{module:e.createShaderModule({code:U(r,i)}),entryPoint:"main",buffers:a},fragment:{module:e.createShaderModule({code:$(r,n)}),entryPoint:"main",targets:[{format:t,blend:{color:"BLEND"!==n.alphaMode?{operation:"add",srcFactor:"one",dstFactor:"zero"}:{operation:"add",srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{operation:"add",srcFactor:"zero",dstFactor:"one"}}}]},primitive:{topology:"triangle-list",cullMode:n.doubleSided?"none":"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus"}})}(s,o,a,r,n.matrices.length/2);const m=[{binding:0,resource:{buffer:n.matrixBuffer}}];d.forEach(((e,t)=>{if(e){const{addressModeU:n,addressModeV:r,magFilter:i,minFilter:o}=e.sampler;m.push({binding:2*t+1,resource:s.createSampler({addressModeU:n,addressModeV:r,magFilter:i,minFilter:o})}),m.push({binding:2*t+2,resource:this.textures[e.source].createView()})}})),r.uniformBindGroup=s.createBindGroup({layout:r.pipeline.getBindGroupLayout(1),entries:m})}))}))}destroy(){this.camera.destroy(),Object.entries(this.meshes).forEach((([,e])=>{e.matrixBuffer.destroy(),e.primitives.forEach((e=>{e.destroy()}))})),Object.entries(this.textures).forEach((([,e])=>e.destroy()))}}var N=function(e,t,n,r){return new(n||(n=Promise))((function(i,s){function o(e){try{l(r.next(e))}catch(e){s(e)}}function a(e){try{l(r.throw(e))}catch(e){s(e)}}function l(e){var t;e.done?i(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(o,a)}l((r=r.apply(e,t||[])).next())}))};const L=n(466);class D{constructor(e,t,n,r){this.canvas=e,this.device=t,this.context=n,this.contextFormat=r;let i=t.createTexture({size:[e.clientWidth*devicePixelRatio,e.clientHeight*devicePixelRatio],format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT});this.renderPassDesc={colorAttachments:[],depthStencilAttachment:{view:i.createView(),depthLoadValue:1,depthStoreOp:"store",stencilLoadValue:0,stencilStoreOp:"store"}},window.addEventListener("resize",(()=>{const s=[e.clientWidth*devicePixelRatio,e.clientHeight*devicePixelRatio];n.configure({device:t,format:r,size:s}),i.destroy(),i=t.createTexture({size:s,format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT}),this.renderPassDesc.depthStencilAttachment.view=i.createView()})),this.stats=new L,this.stats.showPanel(0),this.stats.dom.style.left="",this.stats.dom.style.right="0px",document.body.appendChild(this.stats.dom)}render(){const e=()=>{this.stats.begin();const t=this.device.createCommandEncoder();this.renderPassDesc.colorAttachments=[{view:this.context.getCurrentTexture().createView(),loadValue:{r:.3,g:.5,b:.7,a:1},storeOp:"store"}];const n=t.beginRenderPass(this.renderPassDesc);this.scene.camera.bind(this.device,n),Object.entries(this.scene.meshes).forEach((([,e])=>{e.primitives.forEach((t=>{t.isTransparent||t.draw(n,e.matrices.length/2)}))})),Object.entries(this.scene.meshes).forEach((([,e])=>{e.primitives.forEach((t=>{t.isTransparent&&t.draw(n,e.matrices.length/2)}))})),n.endPass(),this.device.queue.submit([t.finish()]),this.stats.end(),void 0!==this.requestId&&(this.requestId=requestAnimationFrame(e))};this.requestId=requestAnimationFrame(e)}load(e){var t;return N(this,void 0,void 0,(function*(){this.gltf=yield function(e){return w(this,void 0,void 0,(function*(){if("gltf"===e.split(".").pop()){const t=yield function(e){return new Promise((t=>{const n=new XMLHttpRequest;n.overrideMimeType("application/json"),n.open("GET",e),n.onreadystatechange=()=>{4===n.readyState&&200===n.status&&t(JSON.parse(n.responseText))},n.send(null)}))}(e);return T(t,e)}const t=yield p(e),n=new Uint32Array(t,12,1)[0],r=new Uint8Array(t,20,n);return T(JSON.parse(new TextDecoder("utf-8").decode(r)),e,t,28+n)}))}(e),void 0!==this.requestId&&cancelAnimationFrame(this.requestId),null===(t=this.scene)||void 0===t||t.destroy(),this.scene=new j(this.gltf,this.gltf.defaultScene,this.canvas,this.device,this.contextFormat),this.render()}))}getCameraCount(){return this.scene?this.scene.cameras.length:0}setCamera(e){var t;null===(t=this.scene)||void 0===t||t.camera.destroy(),this.scene&&(this.scene.camera=new V(this.canvas,this.device,this.scene.aabb,void 0!==e?this.scene.cameras[e]:void 0))}}var z=function(e,t,n,r){return new(n||(n=Promise))((function(i,s){function o(e){try{l(r.next(e))}catch(e){s(e)}}function a(e){try{l(r.throw(e))}catch(e){s(e)}}function l(e){var t;e.done?i(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(o,a)}l((r=r.apply(e,t||[])).next())}))};const q=document.getElementById("webgpu-canvas"),_=document.getElementById("model-select"),H=document.getElementById("camera-select"),X=document.createElement("option");X.innerHTML="User Camera",X.value="User Camera";const W=document.getElementById("glb-upload");fetch("https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/model-index.json").then((e=>e.json())).then((e=>{e.forEach((e=>z(void 0,void 0,void 0,(function*(){const t=document.createElement("option");if(t.innerHTML=e.name,t.value=`https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/${e.name}/glTF/${e.name}.gltf`,_.add(t),"DamagedHelmet"===e.name){_.value=t.value;const e=yield function(e){return N(this,void 0,void 0,(function*(){const t=navigator.gpu;if(!t)throw new Error("WebGPU is not supported on this browser.");const n=yield t.requestAdapter(),r=yield n.requestDevice(),i=e.getContext("webgpu"),s=i.getPreferredFormat(n);return i.configure({device:r,format:s,size:[e.clientWidth*devicePixelRatio,e.clientHeight*devicePixelRatio]}),new D(e,r,i,s)}))}(q),n=t=>z(void 0,void 0,void 0,(function*(){yield e.load(t),H.innerHTML="",H.add(X);for(let t=0;t<e.getCameraCount();t+=1){const e=document.createElement("option");e.innerHTML=String(t),e.value=String(t),H.add(e)}}));n(_.value),_.onchange=()=>n(_.value),H.onchange=()=>{e.setCamera("User Camera"!==H.value?Number(H.value):void 0)},W.onchange=()=>{n(URL.createObjectURL(W.files[0]))}}}))))}))})()})();